<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="José Luis Ramírez" />


<title>Solución Numérica de Ecuaciones No Lineales</title>

<script src="site_libs/header-attrs-2.30/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.5.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="css/estilos.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Métodos Numéricos</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/jlramirezb">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Solución Numérica de Ecuaciones No
Lineales</h1>
<h4 class="author">José Luis Ramírez</h4>
<h4 class="date">Noviembre 2025</h4>

</div>


<div id="motivación" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Motivación</h1>
<ul>
<li><p>La determinación de las raíces de una ecuación o de un sistema de
ecuaciones, es uno de los problemas más antiguos de aproximación
numérica que se presenta con frecuencia en la solución de una gran
variedad de problemas en la matemática aplicada.</p></li>
<li><p>En muchos problemas de ingeniería, inteligencia artificial u
otras disciplinas afines tenemos que resolver ecuaciones del tipo <span
class="math inline">\(f(x)=0\)</span>, donde <span
class="math inline">\(f\)</span> es una función que dada una cantidad
<span class="math inline">\(x\)</span>, nos devuelve <span
class="math inline">\(f(x)\)</span>.</p></li>
</ul>
<div id="ejemplo-1" class="section level4 caja-ejemplo"
number="1.0.0.1">
<h4><span class="header-section-number">1.0.0.1</span> Ejemplo 1</h4>
<p>Se considera por ejemplo la siguiente ecuación obtenida a partir de
la segunda ley de Newton para calcular la velocidad de un paracaidista,
<span class="math display">\[
v=\dfrac{g \cdot m}{c}\left(1-e^{\frac{c}{m}t}\right)
\]</span> donde la velocidad <span class="math inline">\(v\)</span>
depende de la variable independiente tiempo, <span
class="math inline">\(t\)</span>, <span class="math inline">\(g\)</span>
es la constante de gravitación, <span class="math inline">\(c\)</span>
el coeficiente de resistencia y <span class="math inline">\(m\)</span>
es la masa del paracaidista.</p>
<p>Si se quisiera obtener el coeficiente de resistencia del paracaidista
con una masa dada, ¿cómo se obtendría este valor para alcanzar una
velocidad determinada en un periodo establecido? La respuesta se
obtendría calculando <span class="math inline">\(c\)</span> que hace
cero a la siguiente función: <span class="math display">\[
f(c) = \dfrac{g \cdot m}{c}\left(1-e^{\frac{c}{m}t}\right)-v
\]</span></p>
<p>esto es, habría que calcular el valor de <span
class="math inline">\(c\)</span> tal que <span
class="math inline">\(f(c)=0\)</span>.</p>
<p>En este caso no es posible encontrar analíticamente el cero de la
función o su cálculo es complicado.</p>
</div>
<ul>
<li><p>En dichos problemas, conocer explícitamente la función <span
class="math inline">\(f\)</span> en muchos casos no es posible, sólo
tenemos un algoritmo que dado un valor <span
class="math inline">\(x\)</span>, nos devuelve <span
class="math inline">\(f(x)\)</span>.</p></li>
<li><p>Entonces, dependiendo de nuestro conocimiento de la función <span
class="math inline">\(f\)</span>, podremos aplicar un método numérico u
otro.</p></li>
<li><p>Todos los métodos numéricos que hallan aproximaciones de ceros
construyen una <strong>sucesión</strong> <span
class="math inline">\(\{x_n\}_n\)</span> que queremos que converja hacia
el cero <span class="math inline">\(\hat{x}\)</span> de la función <span
class="math inline">\(f\)</span>.</p></li>
<li><p>Cuanto mayor sea la <strong>velocidad de convergencia</strong> de
la sucesión <span class="math inline">\(\{x_n\}_n\)</span>, mejor será
el método usado.</p></li>
</ul>
<div id="método-gráfico" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Método Gráfico</h2>
<p>El método gráfico es un método muy simple, consiste en calcular
valores de la variable dependiente para distintos valores de la variable
independiente, para luego observar el punto de intersección de la
función con el eje de las abscisas. Este punto proporciona una primera
aproximación a la raíz de la ecuación.</p>
<p><img src="unidad03_files/figure-html/unnamed-chunk-1-7.png" width="960" /></p>
</div>
</div>
<div id="velocidad-de-convergencia" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Velocidad de
convergencia</h1>
<p>Se distinguen distintas velocidades de convergencia que se pasarán a
definir.</p>
<div class="caja-lema">
<p><strong>Definición:</strong></p>
<p>Dada una sucesión de números reales, <span
class="math inline">\(\left\{x _k\right\}_{k = 1}^{\infty}\)</span>,
convergente hacia un punto <span class="math inline">\(\overline
x\)</span>, se dice que su orden o velocidad de convergencia es <span
class="math inline">\(p\)</span>, con <span class="math inline">\(p \ge
1\)</span> si existe una constante <span class="math inline">\(C_p \ge
0\)</span> tal que:</p>
<div class="recuadro-gris">
<p><span class="math display">\[\left| {{x_{k + 1}} - \overline x }
\right| \le {C_p}{\left| {{x_k} - \overline x \,} \right|^p}
\]</span></p>
</div>
<p>para todo <span class="math inline">\(k \ge k_0\)</span> siendo <span
class="math inline">\(k_0\)</span> entero.</p>
</div>
<p>En particular,</p>
<ul>
<li><p>Si <span class="math inline">\(p=1\)</span> y <span
class="math inline">\(C_p&lt; 1\)</span>, la convergencia es
<strong>lineal</strong>. Si <span class="math inline">\(C_p \ge
1\)</span>, la convergencia es <strong>sublineal</strong>.</p></li>
<li><p>Si <span class="math inline">\(p=2\)</span>, la convergencia es
<strong>cuadrática</strong>.</p></li>
<li><p>Si <span class="math inline">\(p=3\)</span>, la convergencia es
<strong>cúbica</strong>.</p></li>
</ul>
<div id="ejemplo-2" class="section level4 caja-ejemplo"
number="2.0.0.1">
<h4><span class="header-section-number">2.0.0.1</span> Ejemplo 2</h4>
<p>Se considera la sucesión <span class="math inline">\({x_k} =
\frac{1}{6} - \frac{1}{3}{\left(-\frac{1}{2}\right)^k}\)</span> que
converge a <span class="math inline">\(\frac{1}{6}\)</span>. Se ve que
la convergencia es lineal.</p>
<p>Se puede comprobar que: <span class="math display">\[
\left|x_{k + 1} - \frac{1}{6} \right| \le \frac{1}{2}\left|x_k -
\frac{1}{6} \right|
\]</span> ya que <span class="math display">\[
\left|x_{k + 1} - \frac{1}{6}\right| = \frac{1}{3 \cdot 2^{k + 1}}
\qquad \left|x_k - \frac{1}{6} \right| = \frac{1}{3 \cdot 2^k}
\]</span></p>
</div>
<div id="ejemplo-3" class="section level4 caja-ejemplo"
number="2.0.0.2">
<h4><span class="header-section-number">2.0.0.2</span> Ejemplo 3</h4>
<p>Suponga que <span class="math inline">\(C_p=0.5\)</span> y que <span
class="math inline">\(\left| x_k - \overline x \right| &lt;
0.01\)</span>. Considerando <span class="math inline">\(p=1\)</span> y
<span class="math inline">\(p=2\)</span>, analiza cómo se aproxima al
valor límite, que se denotará por <span class="math inline">\(\overline
x\)</span>, considerando el término <span
class="math inline">\(k+1\)</span> y <span
class="math inline">\(k+2\)</span> de la sucesión <span
class="math inline">\(\{x_k\}\)</span>.</p>
<p>Se tiene que</p>
<ul>
<li><p>Si <span class="math inline">\(p=1\)</span>, <span
class="math display">\[
\begin{align*}
\left| x_{k + 1} - \overline x \right| &amp;&lt; C_p\left| x_{k} -
\overline x \right| &lt; 5 \cdot 10^{-1} \cdot 10^{-2} = 5 \cdot
10^{-3}\\
\left| x_{k + 2} - \overline x \right| &amp;&lt; C_p \left| x_{k + 1} -
\overline x \right| &lt;5 \cdot 10^{-1} \cdot (5 \cdot 10^{-3}) =25
\cdot 10^{-4}
\end{align*}
\]</span></p></li>
<li><p>Si <span class="math inline">\(p=2\)</span>, <span
class="math display">\[
\begin{align*}
\left| x_{k + 1} - \overline x \right| &amp; &lt; C_p\left| x_{k} -
\overline x \right|^2 &lt; 5 \cdot 10^{-1} \cdot (10^{-2})^2 =5 \cdot
10^{-5}\\
\left| x_{k + 2} - \overline x \right| &amp; &lt; C_p \left| x_{k + 1} -
\overline x \right|^2 &lt; 5 \cdot 10^{-1} \cdot (5\cdot 10^{-5})^2=125
\cdot 10^{-11}
\end{align*}
\]</span></p></li>
</ul>
</div>
</div>
<div id="método-de-bisección" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Método de
Bisección</h1>
<div class="caja-lema">
<p><strong>Teorma del Valor Intermedio de Bolzano</strong></p>
<p>Supongamos que <span class="math inline">\(f \in \mathcal{C}[a,
b]\)</span> y que <span class="math inline">\(L\)</span> es cualquier
número entre <span class="math inline">\(f(a)\)</span> y <span
class="math inline">\(f(b)\)</span>. Entonces existe un número <span
class="math inline">\(c\)</span> en <span class="math inline">\((a,
b)\)</span> tal que <span class="math inline">\(f(c) = L\)</span>.</p>
</div>
<ul>
<li><p>Supongamos que <span class="math inline">\(f\)</span> es una
función continua en un intervalo <span class="math inline">\([a,
b]\)</span>, y <span class="math inline">\(f(a) \cdot f(b) &lt;
0\)</span>. Entonces, por el <strong>Teorema de Bolzano</strong>, existe
al menos un <span class="math inline">\(p \in (a, b)\)</span>, tal que
<span class="math inline">\(f(p) = 0\)</span>.</p></li>
<li><p>El método, también llamado <strong>método de intervalos
encajados</strong>, va construyendo una sucesión de intervalos
encajados: <span class="math display">\[
[a_0,b_0] \supset[a_1,b_1]\supset\cdots\supset[a_n,b_n]\supset\cdots
\]</span> tal que el cero <span class="math inline">\(x\)</span> siempre
está en todos los intervalos <span
class="math inline">\([a_n,b_n]\)</span> y la longitud de cada intervalo
<span class="math inline">\([a_n,b_n]\)</span> vale <span
class="math inline">\(\frac{b_0-a_0}{2^n}\)</span>. De esta manera el
cero x se calcula de forma más precisa.</p></li>
<li><p>Una primera aproximación de este punto <span
class="math inline">\(p\)</span> puede ser el punto medio:</p></li>
</ul>
<div class="recuadro-gris">
<p><span class="math display">\[
p_1 = \dfrac{a_0+b_0}{2}
\]</span></p>
</div>
<ul>
<li><p>Dado que la función es continua, si <span
class="math inline">\(f(a) \cdot f(p_1) &lt; 0\)</span> en el intervalo
<span class="math inline">\([a, p_1]\)</span> habrá al menos una
solución de la ecuación.</p></li>
<li><p>Y si <span class="math inline">\(f(a) \cdot f(p_1) &gt;
0\)</span> en el intervalo <span class="math inline">\([p_1, b]\)</span>
existirá al menos una raíz.</p></li>
<li><p>Por tanto se habrá definido un nuevo intervalo <span
class="math inline">\([a_1, b_1]\)</span> en el que existirá una
solución. Al que puede aplicársele nuevamente el proceso
anterior.</p></li>
</ul>
<p>A continuación, se ilustra gráficamente el funcionamiento del método
de bisección para la función <span class="math inline">\(f(x) = x^2 -
4\sin(x)\)</span> en el intervalo inicial <span
class="math inline">\([1, 3]\)</span>.</p>
<p><img src="unidad03_files/figure-html/unnamed-chunk-2-9.png" width="1152" /></p>
<div class="cuadro-alg">
<p><strong>FUNCION BISECCION (f,a,b,TOL,N_MAX)</strong></p>
<pre><code># f: la función para la cual se busca la raíz
# a, b: los extremos del intervalo inicial [a, b]
# TOL: la tolerancia para el criterio de parada
# N_MAX: el número máximo de iteraciones

# Paso 1: Verificar la condición inicial (f(a) y f(b) deben tener signos opuestos)
SI f(a) * f(b) &gt;= 0 ENTONCES
    IMPRIMIR &quot;El método de bisección puede no funcionar. f(a) y f(b) deben tener signos opuestos.&quot;
    RETORNAR NULO
FIN SI

# Paso 2: Inicializar el contador de iteraciones
  iteracion = 0

# Paso 3: Bucle principal de iteraciones
MIENTRAS iteracion &lt; N_MAX:
  # Calcular el punto medio del intervalo
  p = (a + b) / 2

  # Paso 4: Evaluar el criterio de parada (si f(p) es suficientemente cercano a cero)
  SI ABS(f(p)) &lt; TOL ENTONCES
    IMPRIMIR &quot;Raíz encontrada en p =&quot;, p, &quot;en&quot;, iteracion, &quot;iteraciones.&quot;
    RETORNAR p
  FIN SI

  # Paso 5: Actualizar el intervalo
  SI f(a) * f(p) &lt; 0 ENTONCES
    # La raíz está en el subintervalo [a, p]
    b = p
  SINO
    # La raíz está en el subintervalo [p, b]
    a = p
  FIN SI

  # Paso 6: Incrementar el contador de iteraciones
  iteracion = iteracion + 1

  # Opcional: Criterio de parada basado en la longitud del intervalo
  SI (b - a) / 2 &lt; TOL ENTONCES
    p = (a + b) / 2
    IMPRIMIR &quot;Intervalo suficientemente pequeño. Raíz aproximada en p =&quot;, p, &quot;en&quot;, iteracion, &quot;iteraciones.&quot;
    RETORNAR p
  FIN SI
FIN MIENTRAS

# Paso 7: Si se alcanza el número máximo de iteraciones sin encontrar la raíz
IMPRIMIR &quot;Número máximo de iteraciones alcanzado. El método puede no haber convergido a la tolerancia deseada.&quot;
RETORNAR (a + b) / 2 # Devolver la última aproximación</code></pre>
<p><strong>FIN FUNCION</strong></p>
</div>
<div id="ejemplo-4-bisección-con-seguimiento-en-tabla"
class="section level4 caja-ejemplo" number="3.0.0.1">
<h4><span class="header-section-number">3.0.0.1</span> Ejemplo 4:
Bisección con seguimiento en tabla</h4>
<p>A continuación, se aplica el método de bisección para encontrar una
raíz de la función <span class="math inline">\(f(x) = x^4 - 2x^3 - 4x^2
+ 4x + 4\)</span> en el intervalo <span class="math inline">\([-2,
-1]\)</span>. La tabla muestra el progreso del método en cada
iteración.</p>
<p>Verificando la hipótesis inicial del Método de Bisección <span
class="math display">\[
f(-2) = (-2)^4-2(-2)^3-4(-2)^2+4(-2)+4 = 16+16-16-8+4 =12
\]</span> <span class="math display">\[
f(-1) = (-1)^4-2(-1)^3-4(-1)^2+4(-1)+4 = 1+2-4-4+4 =-1
\]</span></p>
<p>Se observa que <span class="math inline">\(f(-2)\cdot
f(-1)&lt;0\)</span>, por lo tanto el Teorema de Bolzano asegura la
existencia de un valor <span class="math inline">\(p\in(-2,-1)\)</span>
tal que <span class="math inline">\(f(p)=0\)</span></p>
<pre><code>## Solución encontrada después de 17 iteraciones.</code></pre>
<pre><code>## Tabla de iteraciones del Método de Bisección:</code></pre>
<pre><code>##  k           a           b         p_k   |f(p_k)|    (b-a)/2 |p - pant|
##  1 -2.00000000 -1.00000000 -1.50000000 8.1250e-01 5.0000e-01 0.0000e+00
##  2 -1.50000000 -1.00000000 -1.25000000 9.0234e-01 2.5000e-01 2.5000e-01
##  3 -1.50000000 -1.25000000 -1.37500000 2.8882e-01 1.2500e-01 1.2500e-01
##  4 -1.50000000 -1.37500000 -1.43750000 1.9533e-01 6.2500e-02 6.2500e-02
##  5 -1.43750000 -1.37500000 -1.40625000 6.2667e-02 3.1250e-02 3.1250e-02
##  6 -1.43750000 -1.40625000 -1.42187500 6.2263e-02 1.5625e-02 1.5625e-02
##  7 -1.42187500 -1.40625000 -1.41406250 1.2081e-03 7.8125e-03 7.8125e-03
##  8 -1.42187500 -1.41406250 -1.41796875 3.0274e-02 3.9062e-03 3.9062e-03
##  9 -1.41796875 -1.41406250 -1.41601562 1.4470e-02 1.9531e-03 1.9531e-03
## 10 -1.41601562 -1.41406250 -1.41503906 6.6152e-03 9.7656e-04 9.7656e-04
## 11 -1.41503906 -1.41406250 -1.41455078 2.6996e-03 4.8828e-04 4.8828e-04
## 12 -1.41455078 -1.41406250 -1.41430664 7.4477e-04 2.4414e-04 2.4414e-04
## 13 -1.41430664 -1.41406250 -1.41418457 2.3192e-04 1.2207e-04 1.2207e-04
## 14 -1.41430664 -1.41418457 -1.41424561 2.5636e-04 6.1035e-05 6.1035e-05
## 15 -1.41424561 -1.41418457 -1.41421509 1.2204e-05 3.0518e-05 3.0518e-05
## 16 -1.41421509 -1.41418457 -1.41419983 1.0986e-04 1.5259e-05 1.5259e-05
## 17 -1.41421509 -1.41419983 -1.41420746 4.8830e-05 7.6294e-06 7.6294e-06</code></pre>
<p><img src="unidad03_files/figure-html/unnamed-chunk-3-11.png" width="960" /></p>
</div>
<ul>
<li>Observaciones:
<ul>
<li>Vemos que el método, es lento. Por ejemplo, para pasar de un error
menor que 0.1 a un error menor que 0.01, usando el método de parada
<span class="math inline">\(|f(x_n)|&lt;\epsilon\)</span>, se necesitan
cuatro iteraciones apriximadamente, o sea, se necesitan cuatro
iteraciones para “ganar” una cifra significativa en la aproximación del
cero.</li>
<li>Los dos criterios de parada (dos últimas columnas) son equivalentes
en el sentido que el nuevo aproximado <span
class="math inline">\(p_k\)</span> se encuentra en el punto del
intervalo <span class="math inline">\([a_{k-1},b_{k-1}]\)</span>.</li>
<li>Los dos criterios de parada (columna 4 y 6) son equivalentes desde
el punto de vista de que se necesitan aproximadamente el mismo número de
iteraciones para que se “gane” una cifra significativa en el cero.
Además, los valores que se obtienen con los dos criterios son del mismo
orden, es decir, que si en la iteración <span
class="math inline">\(n\)</span>, <span
class="math inline">\(|f(x_n)|\approx c_1⋅10^{-k}\)</span>, entonces
<span class="math inline">\(|x_n-x_{n-1}|\approx c_2⋅10^{-k}\)</span>;
por ejemplo para <span class="math inline">\(n=13\)</span>, <span
class="math inline">\(|f(x_{13})|\approx 2.31\cdot 10^{-4}\)</span> y
<span class="math inline">\(|x_{13}-x_{12}|\approx 1.22\cdot
10^{-4}\)</span>.</li>
</ul></li>
</ul>
</div>
<div id="método-de-punto-fijo" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Método de Punto
Fijo</h1>
<ul>
<li><p>El método del punto fijo consiste en transformar la ecuación
<span class="math inline">\(f(x)=0\)</span> en la ecuación <span
class="math inline">\(x=g(x)\)</span> mediante operaciones algebraicas
“básicas”.</p></li>
<li><p>Entonces el cero de la ecuación <span
class="math inline">\(f(x)=0\)</span> se transforma en lo que llamamos
un punto fijo de la función <span
class="math inline">\(g(x)\)</span>:</p></li>
</ul>
<div class="caja-lema">
<p><strong>Definición de Punto Fijo</strong></p>
<p>Sea <span class="math inline">\(g\)</span> una función real de
variable real. Diremos que <span class="math inline">\(\hat{x}\)</span>
es un punto fijo de la función <span class="math inline">\(g\)</span> si
<span class="math inline">\(g(\hat{x})=\hat{x}\)</span>.</p>
</div>
<p><strong>Observación</strong>: Gráficamente, un punto fijo resulta de
la intersección de la recta diagonal <span
class="math inline">\(y=x\)</span> y de la función <span
class="math inline">\(y=g(x)\)</span>.</p>
<p>La idea es considerar la sucesión definida de forma recurrente como
<span class="math inline">\(x_n=g(x_{n-1})\)</span> y ver bajo qué
condiciones la sucesión <span class="math inline">\(\{x_n\}_n\)</span>
converge hacia el punto fijo <span
class="math inline">\(\hat{x}\)</span> de <span
class="math inline">\(g\)</span> que recordemos será el cero de la
función <span class="math inline">\(f\)</span> buscado.</p>
<div class="cuadro-alg">
<p><strong>FUNCIÓN PUNTO_FIJO(g, p0, TOL, N_MAX)</strong></p>
<pre><code># ENTRADA:
#   g: la función de iteración x = g(x)
#   p0: la aproximación inicial
#   TOL: la tolerancia para el criterio de parada
#   N_MAX: el número máximo de iteraciones

# SALIDA:
#   p: la solución aproximada o un mensaje de error

i = 1
MIENTRAS i &lt;= N_MAX:
    # Calcular el siguiente término de la sucesión
    p = g(p0)

    # Verificar el criterio de parada (error absoluto)
    SI |p - p0| &lt; TOL ENTONCES
        IMPRIMIR &quot;Solución encontrada en p =&quot;, p, &quot;en&quot;, i, &quot;iteraciones.&quot;
        RETORNAR p
    FIN SI

    # Actualizar para la siguiente iteración
    i = i + 1
    p0 = p
FIN MIENTRAS

IMPRIMIR &quot;El método fracasó después de&quot;, N_MAX, &quot;iteraciones.&quot;</code></pre>
</div>
<div class="figure">
<img src="unidad03_files/figure-html/unnamed-chunk-4-13.png" alt="Visualización de convergencia y divergencia en el Método de Punto Fijo." width="100%" />
<p class="caption">
Visualización de convergencia y divergencia en el Método de Punto Fijo.
</p>
</div>
<div id="ejemplo-5-punto-fijo-para-fx0-de-4-maneras-diferentes"
class="section level4 caja-ejemplo" number="4.0.0.1">
<h4><span class="header-section-number">4.0.0.1</span> Ejemplo 5: Punto
fijo para <span class="math inline">\(f(x)=0\)</span> de 4 maneras
diferentes</h4>
<p>Hallar numéricamente una de las raíces de <span
class="math inline">\(f(x) = x^2 - x - 2 = 0\)</span>. Sus raíces
exactas son <span class="math inline">\(x_1 = -1\)</span> y <span
class="math inline">\(x_2 = 2\)</span>. Hallando únicamente en el
cálculo de la raíz <span class="math inline">\(\hat{x} = 2\)</span>
tomando como punto de partida <span class="math inline">\(x_0 =
2.1\)</span> y definiendo <span class="math inline">\(g\)</span>
como.</p>
<ul>
<li><p><span class="math inline">\(g_1(x) = x^2-2\)</span></p></li>
<li><p><span class="math inline">\(g_2(x) = \sqrt{x+2}\)</span></p></li>
<li><p><span class="math inline">\(g_3(x) =
1+\dfrac{2}{x}\)</span></p></li>
<li><p><span class="math inline">\(g_4(x) =
\dfrac{x^2+2}{2x-1}\)</span></p></li>
</ul>
<pre><code>## --- Tabla Comparativa de Iteraciones de Punto Fijo ---</code></pre>
<pre><code>##                 g1(x)      g2(x)      g3(x)      g4(x)
## Iters                                                 
## 0      2.10000000e+00 2.10000000 2.10000000 2.10000000
## 1      2.41000000e+00 2.02484567 1.95238095 2.00312500
## 2      3.80810000e+00 2.00620180 2.02439024 2.00000325
## 3      1.25016256e+01 2.00154985 1.98795181 2.00000000
## 4      1.54290643e+02 2.00038743 2.00606061        ---
## 5      2.38036025e+04 2.00009685 1.99697885        ---
## 6      5.66611489e+08 2.00002421 2.00151286        ---
## 7      3.21048580e+17 2.00000605 1.99924414        ---
## 8      1.03072191e+35 2.00000151 2.00037807        ---
## 9      1.06238765e+70        --- 1.99981100        ---
## 10    1.12866751e+140        --- 2.00009451        ---
## 11                ---        --- 1.99995275        ---
## 12                ---        --- 2.00002363        ---
## 13                ---        --- 1.99998819        ---
## 14                ---        --- 2.00000591        ---
## 15                ---        --- 1.99999705        ---</code></pre>
</div>
<div id="existencia-del-punto-fijo" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Existencia del Punto
Fijo</h2>
<p>El teorema siguiente nos dice cuáles son las condiciones de
<strong>existencia</strong> del punto fijo de una función <span
class="math inline">\(g\)</span>:</p>
<div class="caja-lema">
<p><strong>Teorema</strong></p>
<p>En los resultados teóricos que se enuncian a continuación, se dan
condiciones suficientes para que haya un punto fijo de una función <span
class="math inline">\(g\)</span> en un intervalo y para que la
convergencia sea a un único punto fijo.</p>
<ul>
<li><p>Sea <span class="math inline">\(g\)</span> continua en <span
class="math inline">\([a,b]\)</span> que aplica <span
class="math inline">\([a,b]\)</span> en <span
class="math inline">\([a,b]\)</span>, entonces <span
class="math inline">\(g\)</span> tiene un punto fijo en <span
class="math inline">\([a,b]\)</span>.</p></li>
<li><p>Sea <span class="math inline">\(g\)</span> continua en <span
class="math inline">\([a,b]\)</span> con <span
class="math inline">\(g&#39;\)</span> cumpliendo</p></li>
</ul>
<div class="recuadro-gris">
<p><span class="math display">\[
\left| {g&#39;\left( x \right)}\right| \le L &lt; 1 \quad \text{ para
todo }x \in \left(a,b\right)
\]</span></p>
</div>
<ul>
<li>Si <span class="math inline">\(x_0\)</span> es un punto cualquiera
en <span class="math inline">\((a,b)\)</span> entonces la solución</li>
</ul>
<div class="recuadro-gris">
<p><span class="math display">\[
{x_{k + 1}} = g\left( {{x_k}} \right)\qquad k \ge 0
\]</span></p>
</div>
<p>converge al único punto fijo en [a,b].</p>
</div>
<ul>
<li><strong>Observación</strong>:
<ul>
<li>Si al utilizar el método del punto fijo <span
class="math inline">\(x_{k+1}\)</span> y <span
class="math inline">\(x_k\)</span> coinciden dentro de la exactitud
especificada <span class="math inline">\(\epsilon\)</span>, no significa
que <span class="math inline">\(\overline x \approx {x_{k+1}}\)</span>
con la misma exactitud. En general, esta afirmación no es correcta. Si
<span class="math inline">\(g&#39;(x)\)</span> está próxima a la unidad,
entonces la cantidad <span class="math inline">\(\left| {{x_k} -
\overline x} \right|\)</span> puede ser grande, aún cuando <span
class="math inline">\(\left|{{x_{k+1}} - x_k} \right|\)</span> sea
extremadamente pequeña.</li>
</ul></li>
</ul>
<div id="ejemplo-6" class="section level4 caja-ejemplo"
number="4.1.0.1">
<h4><span class="header-section-number">4.1.0.1</span> Ejemplo 6</h4>
<p>La función <span class="math inline">\(g_2 : [1, 3] \to [1,
3]\)</span> definida por <span class="math inline">\(g_2(x) = \sqrt{x +
2}\)</span> cumple con el Teorema dado en <span class="math inline">\(X
= [1, 3]\)</span>.</p>
<ul>
<li>Primero verificando que <span class="math inline">\(g(x) \in [1,
3]\)</span> si <span class="math inline">\(x \in [1, 3]\)</span>:</li>
</ul>
<p><span class="math display">\[
x \in [1, 3] \Leftrightarrow 1 \leq x \leq 3 \Leftrightarrow 3 \leq x+2
\leq 5 \Leftrightarrow \sqrt{3} \leq \sqrt{x + 2} \leq
\sqrt{5}
\]</span> Por lo tanto, <span class="math inline">\(g_2(x) = \sqrt{x +
2} \in [1, 3]\)</span>.</p>
<div class="figure">
<img src="unidad03_files/figure-html/unnamed-chunk-6-15.png" alt="Análisis gráfico de los puntos fijos para las funciones del Ejemplo 5." width="1152" />
<p class="caption">
Análisis gráfico de los puntos fijos para las funciones del Ejemplo 5.
</p>
</div>
</div>
A continuación, se presenta un gráfico dedicado a la convergencia del
error para la funciones <span class="math inline">\(g_2(x)\)</span>,
<span class="math inline">\(g_3(x)\)</span> y <span
class="math inline">\(g_4(x)\)</span>.
<div class="figure">
<img src="unidad03_files/figure-html/unnamed-chunk-7-17.png" alt="Convergencia del error para $g_3$, $g_4$ y $g_5$ en escala logarítmica." width="960" />
<p class="caption">
Convergencia del error para <span class="math inline">\(g_3\)</span>,
<span class="math inline">\(g_4\)</span> y <span
class="math inline">\(g_5\)</span> en escala logarítmica.
</p>
</div>
</div>
</div>
<div id="método-de-newton-raphson" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Método de
Newton-Raphson</h1>
<ul>
<li><p>El método de Newton-Raphson es uno de los métodos más conocidos y
más potentes en el sentido de su <strong>velocidad de
convergencia</strong>.</p></li>
<li><p>Sin embargo, al contrario que el método de la bisección, su
convergencia no está asegurada.</p></li>
<li><p>La idea de este método se basa en la aproximación lineal que
proporciona la recta tangente. Una vez obtenido <span
class="math inline">\(x_k\)</span>, se calcula <span
class="math inline">\(x_{k+1}\)</span> utilizando la aproximación lineal
de <span class="math inline">\(f(x)\)</span> mediante la recta tangente
que pasa por el punto <span
class="math inline">\((x_k,f(x_k))\)</span>:</p></li>
</ul>
<div class="recuadro-gris">
<p><span class="math display">\[
f(x) \approx f(x_k) + f&#39;(x_k)(x-x_k)
\]</span></p>
</div>
<ul>
<li>Se toma <span class="math inline">\(x_{k+1}\)</span> como la
intersección de esta recta con el eje de abscisas, es decir, la solución
de</li>
</ul>
<div class="recuadro-gris">
<p><span class="math display">\[
f(x_k) + f&#39;(x _k )(x - x_k ) = 0
\]</span></p>
</div>
<ul>
<li><p>Si en esta expresión se despeja <span
class="math inline">\(x\)</span> obtenemos una aproximación de <span
class="math inline">\(\hat{x}\)</span> más exacta de lo que era la
estimación <span class="math inline">\(x_k\)</span>.</p></li>
<li><p>Así, detotando como <span class="math inline">\(x_{k+1}\)</span>
a este punto de corte, el Método de Newton-Raphson genera la sucesión de
aproximacioones a partir del valor inicial <span
class="math inline">\(x_0\)</span> dado por el esquema:</p></li>
</ul>
<div class="recuadro-gris">
<p><span class="math display">\[
x_{k+1} = x_k - \dfrac{f(x_k)}{f&#39;(x_k)} \quad k \geq 0
\]</span></p>
</div>
<ul>
<li>Veamos gráficamente en qué consiste el método de
Newton-Raphson:</li>
</ul>
<div class="figure">
<img src="unidad03_files/figure-html/unnamed-chunk-8-19.png" alt="Visualización del Método de Newton-Raphson." width="1152" />
<p class="caption">
Visualización del Método de Newton-Raphson.
</p>
</div>
<div class="cuadro-alg">
<p><strong>FUNCIÓN NEWTON_RAPHSON (f, df, p0, TOL, N_MAX)</strong></p>
<pre><code># ENTRADA:
#   f:      la función para la cual se busca la raíz.
#   df:     la derivada de la función f.
#   p0:     la aproximación inicial.
#   TOL:    la tolerancia para el criterio de parada.
#   N_MAX:  el número máximo de iteraciones.

# SALIDA:
#   p:      la solución aproximada o un mensaje de error.

# Paso 1: Inicializar el contador de iteraciones.
iteracion = 1

# Paso 2: Iniciar el bucle que se ejecutará hasta N_MAX iteraciones.
MIENTRAS iteracion &lt;= N_MAX:
    # Paso 3: Calcular el siguiente punto usando la fórmula de Newton-Raphson.
    #         Se debe verificar que la derivada no sea cero para evitar una división indefinida.
    SI ABS(df(p0)) &lt; 1E-15 ENTONCES
        IMPRIMIR &quot;Error: La derivada es cero o muy cercana a cero. El método no puede continuar.&quot;
        RETORNAR NULO
    FIN SI

    p = p0 - f(p0) / df(p0)

    # Paso 4: Comprobar si la aproximación es suficientemente buena (criterio de parada).
    #         El error se mide como la diferencia absoluta entre la iteración actual y la anterior.
    SI |p - p0| &lt; TOL ENTONCES
        IMPRIMIR &quot;Solución encontrada en p =&quot;, p, &quot;después de&quot;, iteracion, &quot;iteraciones.&quot;
        RETORNAR p
    FIN SI

    # Paso 5: Actualizar para la siguiente iteración.
    iteracion = iteracion + 1
    p0 = p
    
FIN MIENTRAS

# Paso 6: Si se alcanza el número máximo de iteraciones sin converger, mostrar un mensaje.
IMPRIMIR &quot;El método fracasó después de&quot;, N_MAX, &quot;iteraciones. No se alcanzó la convergencia.&quot;</code></pre>
</div>
<div id="ejemplo-7" class="section level4 caja-ejemplo"
number="5.0.0.1">
<h4><span class="header-section-number">5.0.0.1</span> Ejemplo 7</h4>
<p>Obtener la raíz del polinomio <span class="math inline">\(p\left( x
\right) = {x^3} + 3{x^2} + 2\)</span> que se encuentra en el intervalo
<span class="math inline">\([-4,-2]\)</span>. Se puede considerar como
punto de inicio el punto medio del intervalo <span
class="math inline">\(x_0=-3\)</span>, una tolerancia de <span
class="math inline">\(10^{-8}\)</span> y un numero máximo de 50
iteraciones.</p>
<pre><code>## Solución encontrada en la iteración 4.</code></pre>
<pre><code>## --- Tabla de Iteraciones del Método de Newton-Raphson ---</code></pre>
<pre><code>##  k         x_k   |p(x_k)| |x_k - x_{k-1}|
##  0 -3.00000000 2.0000e+00             ---
##  1 -3.22222222 3.0727e-01      2.2222e-01
##  2 -3.19621502 4.4916e-03      2.6007e-02
##  3 -3.19582343 1.0103e-06      3.9159e-04
##  4 -3.19582335 5.6843e-14      8.8118e-08</code></pre>
<div class="figure">
<img src="unidad03_files/figure-html/unnamed-chunk-9-21.png" alt="Convergencia del error para el método de Newton-Raphson." width="960" />
<p class="caption">
Convergencia del error para el método de Newton-Raphson.
</p>
</div>
</div>
<ul>
<li><p>El método de Newton es uno de los métodos más usados para
calcular numéricamente raíces de ecuaciones no lineales, pues si se
escoge adecuadamente la aproximación inicial <span
class="math inline">\(x_0\)</span>, la sucesión obtenida por iteración
converge razonablemente rápido a la solución.</p></li>
<li><p>Sin embargo, este es un método denominado local, pues si <span
class="math inline">\(x_0\)</span> no es lo suficientemente cercano a
<span class="math inline">\(\hat{x}\)</span> y la función <span
class="math inline">\(f(x)\)</span> no tiene <strong>buenas
propiedades</strong>, se pueden presentar algunos problemas. El
siguiente ejemplo muestra algunas de las situaciones indeseables en el
método de Newton.</p></li>
</ul>
<div id="ejemplo-8" class="section level4 caja-ejemplo"
number="5.0.0.2">
<h4><span class="header-section-number">5.0.0.2</span> Ejemplo 8</h4>
<p>Ahora, se resolverá el mismo problema del <strong>Ejemplo 7</strong>,
pero tomando como punto de partida <span
class="math inline">\(x_0=1\)</span>. Este ejemplo ilustra un caso donde
el método de Newton-Raphson no converge a la raíz esperada debido a una
mala elección del punto inicial.</p>
<pre><code>## Se alcanzó el número máximo de 20 iteraciones sin convergencia.</code></pre>
<pre><code>## --- Tabla de Iteraciones con x0 = 1 (Divergencia) ---</code></pre>
<pre><code>##  k         x_k   |p(x_k)| |x_k - x_{k-1}|
##  0  1.00000000 6.0000e+00             ---
##  1  0.33333333 2.3704e+00      6.6667e-01
##  2 -0.68253968 3.0796e+00      1.0159e+00
##  3  0.45904845 2.7289e+00      1.1416e+00
##  4 -0.34677943 2.3191e+00      8.0583e-01
##  5  1.00158613 6.0143e+00      1.3484e+00
##  6  0.33474248 2.3737e+00      6.6684e-01
##  7 -0.67764927 3.0664e+00      1.0124e+00
##  8  0.46302605 2.7424e+00      1.1407e+00
##  9 -0.33854656 2.3050e+00      8.0157e-01
## 10  1.02745275 6.2516e+00      1.3660e+00
## 11  0.35751894 2.4292e+00      6.6993e-01
## 12 -0.60316418 2.8720e+00      9.6068e-01
## 13  0.53310209 3.0041e+00      1.1363e+00
## 14 -0.20843016 2.1213e+00      7.4153e-01
## 15  1.68513962 1.5304e+01      1.8936e+00
## 16  0.86364567 4.8818e+00      8.2149e-01
## 17  0.20567491 2.1356e+00      6.5797e-01
## 18 -1.36352135 5.0425e+00      1.5692e+00
## 19  0.57326211 3.1743e+00      1.9368e+00</code></pre>
<div class="figure">
<img src="unidad03_files/figure-html/unnamed-chunk-10-23.png" alt="Comportamiento divergente del método de Newton-Raphson con un punto inicial inadecuado." width="960" />
<p class="caption">
Comportamiento divergente del método de Newton-Raphson con un punto
inicial inadecuado.
</p>
</div>
</div>
</div>
<div id="método-de-la-secante" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Método de la
Secante</h1>
<ul>
<li><p>El método de Newton es un método muy potente pero tiene un
inconveniente: necesitamos conocer la función derivada <span
class="math inline">\(f&#39;(x)\)</span>.</p></li>
<li><p>En muchos problemas de análisis numérico, dicho conocimiento es
un lujo. Sabemos cómo evaluar la función <span
class="math inline">\(f\)</span> pero no hay forma de tener una
expresión de la función derivada <span
class="math inline">\(f&#39;\)</span>. En estos casos, el metodo de
Newton-Raphson no es aplicable.</p></li>
<li><p>Para solventar esta dificultad, podemos usar el cociente
incremental como aproximación a <span
class="math inline">\(f&#39;(x_{n-1})\)</span>:</p></li>
</ul>
<div class="recuadro-gris">
<p><span class="math display">\[
f&#39;(x_{n-1}) \approx \dfrac{f(x_{n-1})-f(x_{n-2})}{x_{n-1}-x_{n-2}}
\]</span></p>
</div>
<ul>
<li>Si sustituimos la expresión anterior de <span
class="math inline">\(f&#39;(x_{n-1})\)</span> en el método de
Newton-Raphson, obtenemos el denominado metodo de la secante:</li>
</ul>
<div class="recuadro-gris">
<p><span class="math display">\[
x_n = x_{n-1}-
\dfrac{f(x_{n-1})}{\frac{f(x_{n-1})-f(x_{n-2})}{x_{n-1}-x_{n-2}}} =
x_{n-1}-\dfrac{f(x_{n-1})\cdot(x_{n-1}-x_{n-2})}{f(x_{n-1})-f(x_{n-2})}
\]</span></p>
</div>
<ul>
<li>Esta fórmula de iteración puede deducirse de hallar el punto de
corte con el eje <span class="math inline">\(x\)</span> de la recta
secante que pasa por los puntos <span
class="math inline">\((x_{n-2},f(x_{n-2}))\)</span> y <span
class="math inline">\((x_{n-1},f(x_{n-1}))\)</span>, lo cual se puede
ver en el siguiente gráfico:</li>
</ul>
<div class="figure">
<img src="unidad03_files/figure-html/unnamed-chunk-11-25.png" alt="Visualización del Método de la Secante." width="1152" />
<p class="caption">
Visualización del Método de la Secante.
</p>
</div>
<div class="cuadro-alg">
<p><strong>FUNCIÓN SECANTE (f, p0, p1, TOL, N_MAX)</strong></p>
<pre><code># ENTRADA:
#   f:      la función para la cual se busca la raíz.
#   p0, p1: las dos aproximaciones iniciales.
#   TOL:    la tolerancia para el criterio de parada.
#   N_MAX:  el número máximo de iteraciones.

# SALIDA:
#   p:      la solución aproximada o un mensaje de error.

# Paso 1: Inicializar el contador de iteraciones.
iteracion = 1

# Paso 2: Iniciar el bucle que se ejecutará hasta N_MAX iteraciones.
MIENTRAS iteracion &lt;= N_MAX:
    # Paso 3: Calcular el siguiente punto usando la fórmula de la secante.
    #         Se debe verificar que el denominador no sea cero.
    SI ABS(f(p1) - f(p0)) &lt; 1E-15 ENTONCES
        IMPRIMIR &quot;Error: División por cero o un valor muy pequeño. El método no puede continuar.&quot;
        RETORNAR NULO
    FIN SI

    p = p1 - f(p1) * (p1 - p0) / (f(p1) - f(p0))

    # Paso 4: Comprobar si la aproximación es suficientemente buena.
    #         El error se mide como la diferencia absoluta entre la iteración actual y la anterior.
    SI |p - p1| &lt; TOL ENTONCES
        IMPRIMIR &quot;Solución encontrada en p =&quot;, p, &quot;después de&quot;, iteracion, &quot;iteraciones.&quot;
        RETORNAR p
    FIN SI

    # Paso 5: Actualizar las aproximaciones para la siguiente iteración.
    iteracion = iteracion + 1
    p0 = p1
    p1 = p
    
FIN MIENTRAS

# Paso 6: Si se alcanza el número máximo de iteraciones sin converger, mostrar un mensaje.
IMPRIMIR &quot;El método fracasó después de&quot;, N_MAX, &quot;iteraciones. No se alcanzó la convergencia.&quot;</code></pre>
</div>
<div id="ejemplo-9" class="section level4 caja-ejemplo"
number="6.0.0.1">
<h4><span class="header-section-number">6.0.0.1</span> Ejemplo 9</h4>
<p>Se retoma el problema del <strong>Ejemplo 7</strong> para encontrar
la raíz del polinomio <span class="math inline">\(p(x) = x^3 + 3x^2 +
2\)</span>, pero esta vez aplicando el método de la secante. Se
utilizarán como puntos iniciales los extremos del intervalo <span
class="math inline">\([-4, -2]\)</span>, es decir, <span
class="math inline">\(x_0 = -4\)</span> y <span
class="math inline">\(x_1 = -2\)</span>, con una tolerancia de <span
class="math inline">\(10^{-8}\)</span> y un máximo de 50
iteraciones.</p>
<pre><code>## Solución encontrada en la iteración 11.</code></pre>
<pre><code>## --- Tabla de Iteraciones del Método de la Secante ---</code></pre>
<pre><code>##  k         x_k   |p(x_k)| |x_k - x_{k-1}|
##  0 -4.00000000 1.4000e+01             ---
##  1 -2.00000000 6.0000e+00      2.0000e+00
##  2 -2.60000000 4.7040e+00      6.0000e-01
##  3 -4.77777778 3.8582e+01      2.1778e+00
##  4 -2.83666675 3.3143e+00      1.9411e+00
##  5 -2.99022363 2.0874e+00      1.5356e-01
##  6 -3.25148645 6.5876e-01      2.6126e-01
##  7 -3.18881429 8.0035e-02      6.2672e-02
##  8 -3.19560371 2.5177e-03      6.7894e-03
##  9 -3.19582423 1.0172e-05      2.2052e-04
## 10 -3.19582335 1.2838e-09      8.8733e-07
## 11 -3.19582335 7.1054e-15      1.1197e-10</code></pre>
<div class="figure">
<img src="unidad03_files/figure-html/unnamed-chunk-12-27.png" alt="Convergencia del error para el método de la Secante." width="960" />
<p class="caption">
Convergencia del error para el método de la Secante.
</p>
</div>
</div>
<ul>
<li><p>Este método tiene convergencia local si la función <span
class="math inline">\(f\)</span> es derivable cerca de la raíz, si la
raíz es simple y si las aproximaciones iniciales están suficientemente
próximas a ella.</p></li>
<li><p>Su orden de convergencia es el número áureo, <span
class="math inline">\(\phi = \frac{{1 + \sqrt 5 }}{2} \approx
1.618\)</span>, lo que implica una convergencia superlineal, aunque
inferior a la del método de Newton.</p></li>
<li><p>Si las aproximaciones iniciales están demasiado alejadas de la
raíz o si esta es múltiple, el método no asegura la
convergencia.</p></li>
</ul>
</div>
<div id="método-de-regula-falsi" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Método de Regula
Falsi</h1>
<ul>
<li><p>Los métodos de Newton-Raphson y de la secante son métodos
relativamente rápidos en cuanto a su convergencia pero tienen el
inconveniente que no tenemos asegurada dicha convergencia.</p></li>
<li><p>Recordemos el Teorema donde nos dice si el cero es simple (<span
class="math inline">\(f&#39;(\hat x)\neq 0\)</span>), existe un entorno
del cero <span class="math inline">\(\hat x\)</span> tal que para
cualquier valor inicial <span class="math inline">\(x_0\)</span>
perteneciente a dicho entorno, el método de Newton-Raphson es
convergente. El problema es que hallar dicho entorno es un problema
mucho más difícil que hallar el cero en sí.</p></li>
<li><p>Por dicho motivo, de cara a asegurar la convergencia de la
sucesión <span class="math inline">\(\{x_n\}_n\)</span> tenemos el
método de Regula falsi que usa las ventajas de los métodos de la
bisección y de la secante.</p></li>
<li><p>En pocas palabras, el método de regula falsi supone que hay un
cambio de signo entre <span class="math inline">\(x_{n-2}\)</span> y
<span class="math inline">\(x_{n-1}\)</span>, es decir, <span
class="math inline">\(f(x_{n-2})\cdot f(x_{n-1})&lt;0\)</span> y halla
<span class="math inline">\(x_n\)</span> usando el método de la secante.
Como <span class="math inline">\(x_n\)</span> estará entre <span
class="math inline">\(x_{n-2}\)</span> y <span
class="math inline">\(x_{n-1}\)</span> habrá un cambio de signo de <span
class="math inline">\(f\)</span> entre <span
class="math inline">\(x_{n-2}\)</span> y <span
class="math inline">\(x_n\)</span> o entre <span
class="math inline">\(x_{n-1}\)</span> y <span
class="math inline">\(x_n\)</span>.</p></li>
<li><p>Se calcula <span class="math inline">\(x_n\)</span> según el
método de la secante:</p></li>
</ul>
<div class="recuadro-gris">
<p><span class="math display">\[
x_n =
x_{n-1}-\dfrac{f(x_{n-1})\cdot(x_{n-1}-x_{n-2})}{f(x_{n-1})-f(x_{n-2})}
\]</span></p>
</div>
<ul>
<li><p><strong>Caso 1</strong>. Si <span
class="math inline">\(f(x_n)\cdot f(x_{n-1})&lt;0\)</span>, tenemos un
cambio de signo de <span class="math inline">\(f\)</span> en el
intervalo <span class="math inline">\((x_{n-1},x_n)\)</span>. En este
caso, no hacemos nada y la sucesión quedará <span
class="math inline">\(\ldots,x_{n-2},x_{n-1},x_n\)</span></p></li>
<li><p><strong>Caso 2</strong>. Si <span
class="math inline">\(f(x_n)\cdot f(x_{n-2})&lt;0\)</span> tenemos un
cambio de signo de <span class="math inline">\(f\)</span> en el
intervalo <span class="math inline">\((x_{n-2},x_n)\)</span>. En este
caso, cambiamos el orden de <span class="math inline">\(x_{n-2}\)</span>
y <span class="math inline">\(x_{n-1}\)</span> y la sucesión quedará
$,x_{n-1},x_{n-2},x_n.</p></li>
<li><p>Volvemos al paso inicial para hallar <span
class="math inline">\(x_{n+1}\)</span>.</p></li>
</ul>
<div class="figure">
<img src="unidad03_files/figure-html/unnamed-chunk-13-29.png" alt="Visualización del Método de Regula Falsi." width="1152" />
<p class="caption">
Visualización del Método de Regula Falsi.
</p>
</div>
<div class="cuadro-alg">
<p><strong>FUNCIÓN REGULA_FALSI(f, a, b, TOL, N_MAX)</strong></p>
<pre><code># ENTRADA:
#   f:      la función para la cual se busca la raíz.
#   a, b:   los extremos del intervalo [a, b] donde f(a) * f(b) &lt; 0.
#   TOL:    la tolerancia para el criterio de parada.
#   N_MAX:  el número máximo de iteraciones.

# SALIDA:
#   p:      la solución aproximada o un mensaje de error.

# Paso 1: Verificar la condición inicial.
SI f(a) * f(b) &gt;= 0 ENTONCES
    IMPRIMIR &quot;Error: f(a) y f(b) deben tener signos opuestos.&quot;
    RETORNAR NULO
FIN SI

# Paso 2: Inicializar el contador de iteraciones y la aproximación previa.
iteracion = 0
p_prev = a # O cualquier valor que no sea la primera p

# Paso 3: Iniciar el bucle.
MIENTRAS iteracion &lt; N_MAX:
    # Paso 4: Calcular la nueva aproximación con la fórmula de la secante.
    p = b - f(b) * (b - a) / (f(b) - f(a))

    # Paso 5: Comprobar el criterio de parada.
    SI |p - p_prev| &lt; TOL O ABS(f(p)) &lt; TOL ENTONCES
        IMPRIMIR &quot;Solución encontrada en p =&quot;, p, &quot;después de&quot;, iteracion, &quot;iteraciones.&quot;
        RETORNAR p
    FIN SI

    # Paso 6: Actualizar el intervalo.
    SI f(a) * f(p) &lt; 0 ENTONCES
        b = p
    SINO
        a = p
    FIN SI

    # Paso 7: Actualizar para la siguiente iteración.
    p_prev = p
    iteracion = iteracion + 1
    
FIN MIENTRAS

# Paso 8: Si se alcanza el número máximo de iteraciones.
IMPRIMIR &quot;El método fracasó después de&quot;, N_MAX, &quot;iteraciones.&quot;
RETORNAR p</code></pre>
</div>
<div id="ejemplo-10" class="section level4 caja-ejemplo"
number="7.0.0.1">
<h4><span class="header-section-number">7.0.0.1</span> Ejemplo 10</h4>
<p>Se retoma el problema del <strong>Ejemplo 7</strong> para encontrar
la raíz del polinomio <span class="math inline">\(p(x) = x^3 + 3x^2 +
2\)</span>, pero esta vez aplicando el método de Regula Falsi. Se
utilizarán como puntos iniciales los extremos del intervalo <span
class="math inline">\([-4, -2]\)</span>, es decir, <span
class="math inline">\(a = -4\)</span> y <span class="math inline">\(b =
-2\)</span>, con una tolerancia de <span
class="math inline">\(10^{-8}\)</span> y un máximo de 50
iteraciones.</p>
<pre><code>## Solución encontrada en la iteración 18.</code></pre>
<pre><code>## --- Tabla de Iteraciones del Método de Regula Falsi ---</code></pre>
<pre><code>##  k         a_k         b_k         p_k   |p(p_k)| |p_k - p_{k-1}|
##  0 -4.00000000 -2.00000000 -2.60000000 4.7040e+00             ---
##  1 -4.00000000 -2.60000000 -2.95209581 2.4175e+00      3.5210e-01
##  2 -4.00000000 -2.95209581 -3.10640002 9.7327e-01      1.5430e-01
##  3 -4.00000000 -3.10640002 -3.16448444 3.5286e-01      5.8084e-02
##  4 -4.00000000 -3.16448444 -3.18502524 1.2303e-01      2.0541e-02
##  5 -4.00000000 -3.18502524 -3.19212488 4.2313e-02      7.0996e-03
##  6 -4.00000000 -3.19212488 -3.19455918 1.4483e-02      2.4343e-03
##  7 -4.00000000 -3.19455918 -3.19539155 4.9493e-03      8.3237e-04
##  8 -4.00000000 -3.19539155 -3.19567589 1.6904e-03      2.8434e-04
##  9 -4.00000000 -3.19567589 -3.19577300 5.7722e-04      9.7103e-05
## 10 -4.00000000 -3.19577300 -3.19580615 1.9709e-04      3.3157e-05
## 11 -4.00000000 -3.19580615 -3.19581748 6.7296e-05      1.1321e-05
## 12 -4.00000000 -3.19581748 -3.19582134 2.2978e-05      3.8656e-06
## 13 -4.00000000 -3.19582134 -3.19582266 7.8456e-06      1.3199e-06
## 14 -4.00000000 -3.19582266 -3.19582311 2.6788e-06      4.5066e-07
## 15 -4.00000000 -3.19582311 -3.19582327 9.1466e-07      1.5387e-07
## 16 -4.00000000 -3.19582327 -3.19582332 3.1230e-07      5.2539e-08
## 17 -4.00000000 -3.19582332 -3.19582334 1.0663e-07      1.7939e-08
## 18 -4.00000000 -3.19582334 -3.19582334 3.6409e-08      6.1251e-09</code></pre>
<div class="figure">
<img src="unidad03_files/figure-html/unnamed-chunk-14-31.png" alt="Convergencia del error para el método de Regula Falsi." width="960" />
<p class="caption">
Convergencia del error para el método de Regula Falsi.
</p>
</div>
</div>
<div class="caja-ejemplo">
<div id="ejemplo-comparativo-resolviendo-x10-10" class="section level4"
number="7.0.0.2">
<h4><span class="header-section-number">7.0.0.2</span> Ejemplo
Comparativo: Resolviendo <span
class="math inline">\(x^{10}-1=0\)</span></h4>
<p>Para consolidar la comprensión de los métodos numéricos abordados, se
presenta un ejemplo comparativo final. El objetivo es encontrar la raíz
positiva de la ecuación no lineal <span class="math inline">\(f(x) =
x^{10} - 1 = 0\)</span>. La raíz exacta de esta ecuación es, por
supuesto, <span class="math inline">\(x=1\)</span>. Este conocimiento
nos permite evaluar la precisión y la eficiencia (velocidad de
convergencia) de cada método.</p>
<p>Se aplicarán los siguientes métodos:</p>
<ul>
<li><p><strong>Bisección</strong>: En el intervalo
<code>[0, 1.5]</code>.</p></li>
<li><p><strong>Regula Falsi</strong>: En el intervalo
<code>[0, 1.5]</code>.</p></li>
<li><p><strong>Punto Fijo</strong>: Con una función de iteración <span
class="math inline">\(g(x) = x - 0.05(x^{10}-1)\)</span> y un punto
inicial <span class="math inline">\(p_0=0.5\)</span>.</p></li>
<li><p><strong>Newton-Raphson</strong>: Con un punto inicial <span
class="math inline">\(p_0=0.5\)</span>.</p></li>
<li><p><strong>Secante</strong>: Con los puntos iniciales <span
class="math inline">\(p_0=0.8\)</span> y <span
class="math inline">\(p_1=1.3\)</span>.</p></li>
</ul>
<p>El código en Python implementa estos cinco métodos y presenta una
tabla comparativa con los resultados.</p>
<pre><code>## --- Tabla Comparativa de Métodos para f(x) = x^10 - 1 ---</code></pre>
<pre><code>##         Método Raíz Encontrada  Iteraciones
##      Bisección      1.00000000           27
##     Punto Fijo      0.99999999           34
## Newton-Raphson      1.00000000           43
##        Secante      1.00000000          102
##   Regula Falsi      0.99999979          200</code></pre>
<div class="figure">
<img src="unidad03_files/figure-html/unnamed-chunk-15-33.png" alt="Comparación del número de iteraciones para cada método." width="960" />
<p class="caption">
Comparación del número de iteraciones para cada método.
</p>
</div>
</div>
<div id="análisis-de-los-resultados" class="section level3"
number="7.0.1">
<h3><span class="header-section-number">7.0.1</span> Análisis de los
Resultados</h3>
<p>La tabla y el gráfico comparativo, ahora ordenados por eficiencia,
ilustran de manera clara las diferencias en la velocidad de convergencia
y la robustez de cada método:</p>
<ul>
<li><p>El <strong>Método de Bisección</strong> muestra una convergencia
lineal, predecible y garantizada. Aunque no es el más rápido (28
iteraciones), su robustez lo convierte en una opción muy fiable siempre
que se pueda acotar la raíz.</p></li>
<li><p>El <strong>Método de Punto Fijo</strong> converge linealmente,
pero de forma bastante lenta (34 iteraciones). Su rendimiento depende
críticamente de la elección de la función de iteración <span
class="math inline">\(g(x)\)</span> y del punto inicial. En este caso,
la convergencia es lenta debido a que el valor de <span
class="math inline">\(|g&#39;(x)|\)</span> está muy cerca de 1 para los
puntos iniciales.</p></li>
<li><p><strong>Newton-Raphson</strong>, a menudo el método más rápido,
demuestra ser muy sensible al punto de partida. Con un punto inicial de
<span class="math inline">\(p_0=0.5\)</span>, la primera iteración salta
a un valor muy grande (~51.7), lo que provoca que las siguientes
iteraciones diverjan lentamente en lugar de converger a la raíz,
excediendo el número máximo de iteraciones. Este resultado subraya una
debilidad clave del método: su convergencia no está garantizada y
depende fuertemente de una buena aproximación inicial.</p></li>
<li><p>El <strong>Método de la Secante</strong>, con una elección de
puntos iniciales (<code>0.6</code> y <code>1.25</code>), se observa que
el método requiere 104 iteraciones para llegar a la solución. Las 104
iteraciones sugieren que el algoritmo estuvo operando en una región
donde la función <span class="math inline">\(f(x)\)</span> y/o la
derivada <span class="math inline">\(f&#39;(x)\)</span> tenían un
comportamiento desfavorable, lo que resultó en una tasa de convergencia
asintótica muy baja (cercana a <span
class="math inline">\(1\)</span>).</p></li>
<li><p>El <strong>Método de Regula Falsi</strong> es uno de los más
lentos en este ejemplo (199 iteraciones). Aunque garantiza la
convergencia, sufre cuando la función es muy convexa o cóncava en el
intervalo, como ocurre con <span
class="math inline">\(x^{10}-1\)</span>. Uno de los extremos del
intervalo (<span class="math inline">\(a=0\)</span>) apenas se mueve, lo
que ralentiza la convergencia a un ritmo lineal muy pobre.</p></li>
</ul>
<p>En conclusión, la elección del método numérico implica un compromiso
entre velocidad y robustez. Mientras que Newton-Raphson puede ser
extremadamente rápido, su falta de convergencia garantizada lo hace poco
fiable sin un buen punto de partida. El método de la secante ofrece un
excelente equilibrio, con una convergencia rápida y sin necesidad de la
derivada, siempre que se elijan puntos iniciales razonables. La
bisección, aunque más lenta, es la opción más segura cuando se puede
acotar la raíz.</p>
</div>
</div>
</div>
<div id="guía-de-ejercicios" class="section level1" number="8">
<h1><span class="header-section-number">8</span> Guía de ejercicios</h1>
<p>En el siguiente enlace <code>Ejercicios_Unidad3</code> encontrará una
lista de ejercicios relacionado con los distintos tópicos cubiertos en
esta tercera unidad.</p>
<p>Descargue el PDF de esta guía de ejercicios aqui:</p>
<p><a href="Ejercicios_Unidad3.pdf">Descargar Guía PDF</a></p>
<hr />
<p><small>Última revisión: 23 de noviembre, 2025</small></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
