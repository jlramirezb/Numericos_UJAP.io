<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="José Luis Ramírez" />


<title>Teoría de Errores</title>

<script src="site_libs/header-attrs-2.30/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.5.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="css/estilos.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Métodos Numéricos</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/jlramirezb">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Teoría de Errores</h1>
<h4 class="author">José Luis Ramírez</h4>
<h4 class="date">Octubre 2025</h4>

</div>


<div id="motivación" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Motivación</h1>
<ul>
<li>La gran mayoría de los modelos matemáticos que describen procesos
físicos no pueden resolverse analíticamente.</li>
<li>En una situación práctica, un problema matemático deriva de un
fenómeno físico sobre el cual se han hecho algunas suposiciones para
simplificarlo y poderlo representar matemáticamente.</li>
<li>Una vez formulado el problema, deben diseñarse métodos numéricos
para resolver el problema. La selección o construcción de los algoritmos
apropiados cae propiamente dentro del terreno del Análisis
Numérico.</li>
</ul>
<hr />
</div>
<div id="teoría-de-errores-y-aproximación" class="section level1"
number="2">
<h1><span class="header-section-number">2</span> Teoría de Errores y
Aproximación</h1>
<p>El análisis numérico proporciona métodos computacionales para el
estudio y solución de problemas matemáticos. Debido a que muchos
cálculos son realizados en computadores digitales, es conveniente la
discusión para la implementación de los métodos numéricos como programas
de computador.</p>
<ul>
<li>Desafortunadamente los resultados son afectados por el uso de la
<strong>Aritmética de Precisión Finita</strong>.</li>
<li>Esperamos tener siempre expresiones verdaderas como <span
class="math inline">\(2 + 2 = 4\)</span>, <span
class="math inline">\(3^2 = 9\)</span>, <span
class="math inline">\((\sqrt{5})^2 = 5\)</span>, pero en la aritmética
de precisión finita <span class="math inline">\(\sqrt{5}\)</span> no
tiene un solo número fijo y finito, que lo represente.</li>
</ul>
<p>Los resultados numéricos están influenciados por muchos tipos de
errores, los cuales pueden ser catalogados a grandes rasgos en tres
tipos básicos:</p>
<ul>
<li><strong>Errores inherentes</strong> que existen en los valores de
los datos de entrada, ya sean causados por incertidumbre o por la
naturaleza necesariamente aproximada de la representación.</li>
<li><strong>Errores de discretización</strong> (llamados también de
truncamiento) que surgen al reemplazar procesos límites por su resultado
antes de alcanzar tal límite.</li>
<li><strong>Errores de redondeo</strong> que se originan al utilizar una
aritmética que involucra números con un número finito de dígitos.</li>
</ul>
<div id="errores-absolutos-y-relativos." class="section level2"
number="2.1">
<h2><span class="header-section-number">2.1</span> Errores Absolutos y
Relativos.</h2>
<p>Sea <span class="math inline">\(x\)</span> el valor exacto de un
número real y <span class="math inline">\(\tilde{x}\)</span> el valor
aproximado. Contemplando todos los posibles errores, la relación entre
el resultado exacto y el aproximado es:</p>
<div class="recuadro-gris">
<p><span class="math display">\[
x=\tilde{x}+E
\]</span></p>
</div>
<p>Se define el error absoluto y se denota <span
class="math inline">\(E_a\)</span> como la diferencia <span
class="math inline">\(x − \tilde{x}\)</span>, y se expresa siempre en
valor absoluto.</p>
<div class="recuadro-gris">
<p><span class="math display">\[
E_a = |x - \tilde{x}|
\]</span></p>
</div>
<p>Al cociente entre el error absoluto <span
class="math inline">\(E_a\)</span> y el valor real <span
class="math inline">\(x\)</span> se le denomina error relativo y se
denota por <span class="math inline">\(E_r\)</span>. Se expresa también
en valor absoluto, es decir:</p>
<div class="recuadro-gris">
<p><span class="math display">\[
E_r =\dfrac{|E_a|}{|x|} = \dfrac{|x - \tilde{x}|}{|x|}
\]</span></p>
</div>
<div id="ejemplo-1" class="section level3 caja-ejemplo" number="2.1.1">
<h3><span class="header-section-number">2.1.1</span> Ejemplo 1</h3>
<ul>
<li>Calculemos los errores absolutos y relativos para el valor <span
class="math inline">\(x= 1234.5678\)</span>, con aproximaciones a 4
dígitos <span class="math inline">\(x_1=1234\)</span> y <span
class="math inline">\(x_2=1235\)</span>
<ul>
<li><span class="math inline">\(E_a = |x - x_1| = |1234.5678 - 1234| =
0.5678\)</span>, <span class="math inline">\(E_r = \dfrac{|E_a|}{|x|} =
\dfrac{0.5678}{1234.5678} \approx 5 \times 10^{-4}\)</span>.</li>
<li><span class="math inline">\(E_a = |x - x_2| = |1234.5678 - 1235| =
0.4322\)</span>, <span class="math inline">\(E_r = \dfrac{|E_a|}{|x|} =
\dfrac{0.4322}{1234.5678} \approx 4 \times 10^{-4}\)</span>.</li>
</ul></li>
<li>Calculemos los errores absolutos y relativos para el valor <span
class="math inline">\(x= −0.00004599881234\)</span>, con aproximaciones
a 4 dígitos <span class="math inline">\(x_1=-0.00004599\)</span> y <span
class="math inline">\(x_2=-0.00004600\)</span>
<ul>
<li><span class="math inline">\(E_a = |x - x_1| = |−0.00004599881234 +
0.00004599| = 8.81234 \times 10^{−9}\)</span>, <span
class="math inline">\(E_r = \dfrac{|E_a|}{|x|} =
\dfrac{8.81234×10^{−9}}{0.00004599881234} \approx 2 \times
10^{-4}\)</span>.</li>
<li><span class="math inline">\(E_a = |x - x_2| = |−0.00004599881234 +
0.00004600| = 1.18766 \times 10^{−9}\)</span>, <span
class="math inline">\(E_r = \dfrac{|E_a|}{|x|} = \dfrac{1.18766 \times
10^{−9}}{0.00004599881234} \approx 2.5819 \times 10^{-4}\)</span>.</li>
</ul></li>
</ul>
</div>
<p><u>Observaciones</u>:</p>
<ul>
<li><p>Mirando los ejemplos anteriores, vemos que los <strong>errores
absolutos</strong> dependen de las magnitudes de los valores <span
class="math inline">\(x\)</span>: en el primer ejemplo los errores
absolutos son de orden de <span class="math inline">\(10^{−1}\)</span>;
en cambio, en el segundo, son del orden de <span
class="math inline">\(10^{−9}\)</span>.</p></li>
<li><p>En cambio, los <strong>errores relativos</strong> no se ven
afectados por dichas magnitudes. Por dicho motivo, si queremos estudiar
los errores sin tener en cuenta el orden de los valores <span
class="math inline">\(x\)</span>, hay que usar los <strong>errores
relativos</strong>. Vemos que en los dos ejemplos los errores relativos
son del orden de <span class="math inline">\(10^{−4}\)</span>. ya que
recordemos que las aproxi9maciones son a 4 <strong>cifras decimales
significativas</strong>.</p></li>
</ul>
</div>
<div id="cifras-significativas." class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Cifras
Significativas.</h2>
<p>Se dice que el número <span class="math inline">\(\tilde{x}\)</span>
aproxima al número <span class="math inline">\(x\)</span> con <span
class="math inline">\(t\)</span> dígitos (o cifras) significativas, si
<span class="math inline">\(t\)</span> es el número entero más grande no
negativo para el cual:</p>
<div class="recuadro-gris">
<p><span class="math display">\[E_r&lt;0.5\times10^{-t} \Rightarrow
\dfrac{|x - \tilde{x}|}{|x|} &lt; 0.5 \times 10^{-t}\]</span></p>
</div>
<div id="ejemplo-2" class="section level3 caja-ejemplo" number="2.2.1">
<h3><span class="header-section-number">2.2.1</span> Ejemplo 2</h3>
<p>Sea <span class="math inline">\(\tilde{x} = 3.1416\)</span> una
aproximación al valor <span class="math inline">\(\pi\)</span>, y <span
class="math inline">\(x = 3.1415927\)</span> una mejor aproximación.</p>
<pre class="python"><code>import math
import string
from decimal import Decimal

def redondear(N,signif):
  &quot;&quot;&quot;
      Dado un número real N y un número determinado de cifras significativas signif,
      nos da la aproximación de este número con signif cifras significativas.

        Parámetros:
        * N: número decimal
        * signif: número de digitos representativos

        Valor de retorno
        * número redondeado a signif número de cifras significativas

   &quot;&quot;&quot;
  if int(N)==0:
    return float(round(Decimal(str(N)),signif))
  else:
    return float(round(Decimal(str(N)),signif-1-int(math.log(abs(N),10))))
  
def Err(num,dig):
    &quot;&quot;&quot;
      Dado un número real y un número determinado de cifras significativas,
      nos da el error absoluto y relativo de dicho número.

        Parámetros:
        * num: número decimal
        * dig: número de cifras significativas

        Valor de retorno
        * Error absoluto
        * Error Relativo

    &quot;&quot;&quot;
    err_abs=abs(num-redondear(num,dig))
    err_rel=err_abs/abs(redondear(num,dig))

    print(&quot;El error absoluto es {}&quot;.format(err_abs))
    print(&quot;El error relativo es {}&quot;.format(err_rel))

    return (err_abs, err_rel)

Err(3.1415927,5)</code></pre>
<pre><code>## El error absoluto es 7.300000000043383e-06
## El error relativo es 2.3236567354352506e-06
## (7.300000000043383e-06, 2.3236567354352506e-06)</code></pre>
<p><span class="math display">\[
\begin{align*}
E_a &amp; = |x - \tilde{x}| = |3.1415927 - 3.1416| = 0.0000073 \\
E_r &amp; = \dfrac{|E_a|}{|x|} = \dfrac{0.0000073}{3.1415927} \approx
0.232 \times 10^{-5}&lt; 0.5 \times 10^{-5}
\end{align*}
\]</span> Luego, <span class="math inline">\(\tilde{x}\)</span> aproxima
a <span class="math inline">\(\pi\)</span> con 5 cifras
significativas.</p>
</div>
</div>
<div id="aproximación-de-números." class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Aproximación de
Números.</h2>
<p>Sea <span class="math inline">\(x = a_n\ldots a_0.b_1b_2\ldots \in
\mathbb{R}\)</span> (En cualquier base), para aproximar hasta el <span
class="math inline">\(t\)</span>-ésimo decimal:</p>
<ul>
<li><p>Por <strong>truncamiento</strong></p>
<div class="recuadro-gris">
<p><span class="math display">\[
\tilde{x}_{trunc} = a_n\ldots a_0.b_1b_2\ldots b_t
\]</span></p>
</div></li>
<li><p>Por <strong>redondeo correcto</strong></p>
<div class="recuadro-gris">
<p><span class="math display">\[
\tilde{x}_{redon} = \begin{cases}
a_n\ldots a_0.b_1b_2\ldots b_t &amp; \text{si } b_{t+1} &lt; 5 \\
a_n\ldots a_0.b_1b_2\ldots b_t + \beta^{-t} &amp; \text{si } b_{t+1}
\geq 5
\end{cases}
\]</span></p>
</div></li>
</ul>
</div>
<div id="forma-normalizada-de-números-en-punto-flotante"
class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Forma Normalizada de
Números en Punto Flotante</h2>
<p>Un número en punto flotante en base <span
class="math inline">\(\beta\)</span> con precisión <span
class="math inline">\(t\)</span> es un número que puede representarse en
la forma:</p>
<div class="recuadro-gris">
<p><span class="math display">\[x = \sigma (0.d_1d_2\ldots d_t)_{\beta}
\times \beta^e\]</span></p>
</div>
<p>donde:</p>
<ul>
<li><span class="math inline">\(\sigma\)</span> es el signo del número
(<span class="math inline">\(+1\)</span> o <span
class="math inline">\(-1\)</span>),</li>
<li><span class="math inline">\(d_1d_2\ldots d_t\)</span> son los
dígitos en base <span class="math inline">\(\beta\)</span> (con <span
class="math inline">\(0 \leq d_i &lt; \beta\)</span> y <span
class="math inline">\(d_1 \neq 0\)</span> para la forma
normalizada),</li>
<li><span class="math inline">\(e\)</span> es el exponente entero, y es
tal que <span class="math inline">\(L \geq e \geq U\)</span> para
ciertos enteros <span class="math inline">\(L\)</span> y <span
class="math inline">\(U\)</span>.</li>
<li><span class="math inline">\(t\)</span> es la precisión (número de
dígitos significativos).</li>
</ul>
<p>Una de las características de todo conjunto de punto flotante <span
class="math inline">\(F\)</span> es que es finito y tiene:</p>
<div class="recuadro-gris">
<p><span class="math display">\[
2(\beta - 1)\beta^{t-1}(U - L + 1) + 1
\]</span></p>
</div>
<p>números diferentes (incluyendo el cero), y donde los distintos de
cero están en forma normalizada.</p>
<div id="ejemplo-3" class="section level3 caja-ejemplo" number="2.4.1">
<h3><span class="header-section-number">2.4.1</span> Ejemplo 3</h3>
<p>Sea el conjunto de punto flotante <span
class="math inline">\(F\)</span> con parámetros <span
class="math inline">\(\beta = 2\)</span>(Binario), <span
class="math inline">\(t = 3\)</span>, <span class="math inline">\(L =
-2\)</span>, <span class="math inline">\(U = 2\)</span>. Tal conjunto
<span class="math inline">\(F\)</span> tiene</p>
<div class="recuadro-gris">
<p><span class="math display">\[2(2 - 1)2^{3 - 1}(2 - (-2) + 1) + 1 =
41\]</span></p>
</div>
<p>números diferentes (incluyendo el cero). La lista completa de números
en <span class="math inline">\(F\)</span> es:</p>
<pre class="python"><code>import numpy as np
import matplotlib.pyplot as plt
def generar_punto_flotante(beta, t, L, U):
    numeros = set()
    for signo in [1, -1]:
        for exponente in range(L, U + 1):
            for d1 in range(1, beta):
                for d2 in range(beta):
                    for d3 in range(beta):
                        numero = signo * (d1 * beta**(-1) + d2 * beta**(-2) + d3 * beta**(-3)) * (beta ** exponente)
                        numeros.add(round(numero, 10))  # Redondear para evitar problemas de precisión
    numeros.add(0)  # Incluir el cero
    return sorted(numeros)

# Parámetros del sistema de punto flotante
beta = 2  # Base (binaria)
t = 3     # Dígitos de la mantisa
L = -2    # Exponente mínimo
U = 2     # Exponente máximo
punto_flotante = generar_punto_flotante(beta, t, L, U)
print(&quot;Números en el conjunto de punto flotante F:{}&quot;.format(punto_flotante))</code></pre>
<pre><code>## Números en el conjunto de punto flotante F:[-3.5, -3.0, -2.5, -2.0, -1.75, -1.5, -1.25, -1.0, -0.875, -0.75, -0.625, -0.5, -0.4375, -0.375, -0.3125, -0.25, -0.21875, -0.1875, -0.15625, -0.125, 0, 0.125, 0.15625, 0.1875, 0.21875, 0.25, 0.3125, 0.375, 0.4375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.25, 1.5, 1.75, 2.0, 2.5, 3.0, 3.5]</code></pre>
<pre class="python"><code># --- Visualización de la Recta Real y los Puntos ---
plt.figure(figsize=(12, 2)) # Ajusta el tamaño de la figura (ancho, alto)

# Dibuja la recta real (una línea horizontal)
plt.axhline(0, color=&#39;gray&#39;, linestyle=&#39;-&#39;, linewidth=1) 

# Dibuja los puntos generados sobre la recta &#39;o&#39; para los marcadores, &#39;b&#39; para el color azul, markersize para el tamaño
plt.plot(punto_flotante, np.zeros_like(punto_flotante), &#39;ob&#39;, markersize=5)
plt.plot(0, 0, &#39;go&#39;, markersize=7, label=&#39;Cero&#39;) # &#39;go&#39; = green circle

# Etiquetas y Título
plt.title(f&#39;Representación de Números de Punto Flotante (beta={beta}, t={t}, L={L}, U={U})&#39;)
plt.xlabel(&#39;Recta Real&#39;)

# Ajustes de los ejes para que los puntos sean más visibles
min_val = min(punto_flotante) - 0.5
max_val = max(punto_flotante) + 0.5
x_limits = plt.xlim(min_val, max_val) # Extiende ligeramente los límites del eje X
yticks = plt.yticks([]) # Oculta las marcas del eje Y, ya que solo es una recta horizontal

# Muestra una leyenda si es necesario
plt.legend()
plt.grid(True, linestyle=&#39;:&#39;, alpha=0.7)
plt.show()</code></pre>
<p><img src="unidad01_files/figure-html/unnamed-chunk-2-1.png" width="1152" /></p>
</div>
<ul>
<li>Hay un rango limitado para representar cantidades
<ul>
<li>Hay números grandes positivos y negativos que no pueden ser
representados (overflow)</li>
<li>No pueden representarse números muy pequeños (underflow)</li>
</ul></li>
<li>Hay sólo un número finito de cantidades que puede ser representado
dentro de un rango
<ul>
<li>El grado de precisión es limitado</li>
<li>Para aquellos que no pueden ser representados exactamente, la
aproximación real se puede lograr: truncando o redondeando.</li>
</ul></li>
<li>El intervalo entre números aumenta tanto como los números crecen en
magnitud
<ul>
<li>El error cuantificable más grande ocurrirá para aquellos valores que
caigan justo debajo del límite superior de la primera serie de
intervalos igualmente espaciados.</li>
</ul></li>
</ul>
<p>Vamos a ver cómo se almacena un número real en el ordenador en
<strong>formato binario</strong> usando <strong>64 bits</strong>.</p>
<p>Sea <span class="math inline">\(x\)</span> un número real que
suponemos en formato <strong>binario</strong>.</p>
<p>Escribimos <span class="math inline">\(x\)</span> de la forma
siguiente:</p>
<div class="recuadro-gris">
<p><span class="math display">\[
x=(−1)^s 1.f\times2^{c−1023},
\]</span></p>
</div>
<p>donde</p>
<ul>
<li><p><span class="math inline">\(s\)</span> indica el signo del
número, indicado <span class="math inline">\(s=0\)</span> para los
números positivos y <span class="math inline">\(s=1\)</span>, para los
negativos.</p></li>
<li><p><span class="math inline">\(1.f\)</span> es lo que se llama la
mantisa donde <span class="math inline">\(f\)</span> es una secuencia de
ceros y unos, es decir,</p>
<div class="recuadro-gris">
<p><span class="math display">\[
f= f_1f_2f_3\ldots f_n, \quad f_i \in \{0,1\}
\]</span></p>
</div></li>
<li><p><span class="math inline">\(c \geq 1\)</span> indica el exponente
del número donde se le resta 1023 para poder representar números muy
pequeños en valor absoluto. Escribimos <span
class="math inline">\(c−1023\)</span> en binario como <span
class="math inline">\(c−1023=e_1e_2\ldots e_m\)</span>, con <span
class="math inline">\(e_i \in \{0,1\}\)</span></p></li>
</ul>
<p>Representamos <span class="math inline">\(x\)</span> por tres cajas:
el signo <span class="math inline">\(s\)</span>, la mantisa <span
class="math inline">\(f\)</span> y el exponente <span
class="math inline">\(c−1023\)</span> en binario:</p>
<div class="recuadro-gris">
<p><span class="math display">\[
|s| f_1f_2\ldots f_n| e_1e_2\ldots e_m|
\]</span></p>
</div>
<div id="ejemplo-4" class="section level3 caja-ejemplo" number="2.4.2">
<h3><span class="header-section-number">2.4.2</span> Ejemplo 4:</h3>
<p>Representar el número <span
class="math inline">\(x=31.53173828125\)</span> en formato de punto
flotante de 64 bits. <span class="math display">\[
\begin{align*}
1. &amp; \text{ Determinar el signo } s: \text{ Como } x &gt; 0, \text{
entonces } s = 0. \\
2. &amp; \text{ Convertir } x \text{ a binario: } \\
   &amp; \quad \text{Parte entera: } 31_{10} = 11111_2. \\
   &amp; \quad \text{Parte fraccionaria: } 0.53173828125_{10} =
0.10001000001_2. \\
   &amp; \quad \text{Por lo tanto, } x \text{ en binario es
aproximadamente } 11111.10001000001_2. \\
3. &amp; \text{ Normalizar el número: } \\
   &amp; \quad 11111.10001000001_2. = 1.111110001000001_2 \times 2^4. \\
4. &amp; \text{ Determinar la mantisa } f: \\
   &amp; \quad f = 111110001000001 \\
5. &amp; \text{ Determinar el exponente } c - 1023: \\
   &amp; \quad c = 4 + 1023 = 1027. \\
   &amp; \quad \text{Convertir } 1027 \text{ a binario: } 1027_{10} =
10000000011_2. \\
6. &amp; \text{ Representar el número en formato de 64 bits: } \\
   &amp; \quad |0|111110001000001|10000000011|. \\
\end{align*}
\]</span> Como sólo tenemos 64 bits para representar el número, la
cantidad de bits usados para su representación no puede superar 64</p>
<p>En caso que los superase, tendremos que considerar una aproximación
del mismo.</p>
<p>En el ejemplo se usado el número siguiente de bits:</p>
<ul>
<li>signo: 1 bit,</li>
<li>mantisa: 15 bits,</li>
<li>exponente: 11 bits,</li>
</ul>
<p>en total, 27 bits, por tanto, sí sería posible su representación
exacta y no haría falta considerar una aproximación del mismo.</p>
</div>
<div id="ejemplo-5" class="section level3 caja-ejemplo" number="2.4.3">
<h3><span class="header-section-number">2.4.3</span> Ejemplo 5:</h3>
<p>Hagamos la conversión contraria.</p>
<p>Imaginemos que nos dan el número siguiente: <span
class="math display">\[
|1| 101101110011| 1111|.
\]</span> Vamos a ver a qué número <span
class="math inline">\(x\)</span> corresponde.</p>
<p>El signo es negativo, por tanto <span
class="math inline">\(x&lt;0\)</span></p>
<p>La mantisa será: <span class="math display">\[
1.f=1+\frac{1}{2}+\frac{1}{2^3}+\frac{1}{2^4}+\frac{1}{2^6}+\frac{1}{2^7}+\frac{1}{2^8}+\frac{1}{2^{11}}+\frac{1}{2^{12}}=1.7155762.
\]</span> El exponente <span class="math inline">\(c\)</span> vale <span
class="math inline">\(1111_{2}−1023=1+2+2^2+2^3−1023=−1008\)</span>.</p>
<p>El número será: <span class="math display">\[
x=−1.7155762\times2^{−1008} \approx −6.25424\times10^{−304}.
\]</span></p>
</div>
<hr />
<ul>
<li><p>La combinación aritmética usual <span class="math inline">\(+, −,
\times, \div\)</span> de dos números de punto flotante no siempre
produce un número de punto flotante.</p></li>
<li><p>Supongamos que <span class="math inline">\(fl(x), fl(y) \in
F\)</span>. Veamos, como ejemplo, que la suma usual <span
class="math inline">\(fl(x) + fl(y)\)</span> no necesariamente será un
número en <span class="math inline">\(F\)</span>.</p>
<ul>
<li>Sea el conjunto <span class="math inline">\(F\)</span> dado en el
ejemplo: <span class="math inline">\(fl(x) = 5/32 \in F\)</span>, <span
class="math inline">\(fl(y) = 48/32 \in F\)</span>, sin embargo <span
class="math inline">\(fl(x) + fl(y) = 5/32 + 48/32 = 53/32 \notin
F\)</span>.</li>
</ul></li>
<li><p>Las operaciones aritméticas que realiza un computador no
corresponden de forma exacta con las operaciones usuales. El estudio de
lo que ocurre realmente es difı́cil de realiza y en todo caso depende de
la máquina que se esté utilizand.o</p></li>
<li><p>Denotando por <span class="math inline">\(\oplus, \ominus,
\otimes, \oslash\)</span> las operaciones de suma, resta, multiplicación
y división de la máquina. Se definen estas operaciones por:</p>
<div class="recuadro-gris">
<p><span class="math display">\[
\begin{align*}
x \oplus y &amp; = fl(fl(x) + fl(y))\\
x \ominus y &amp; = fl(fl(x) - fl(y))\\
x \otimes y &amp; = fl(fl(x) \times fl(y))\\
x \oslash y &amp; = fl(fl(x)/fl(y))
\end{align*}
\]</span></p>
</div></li>
</ul>
</div>
<div id="unidad-de-precisión-o-redondeo" class="section level2"
number="2.5">
<h2><span class="header-section-number">2.5</span> Unidad de Precisión o
Redondeo</h2>
<ul>
<li><p>En la representación en punto flotante con <span
class="math inline">\(n\)</span> dígitos en bas <span
class="math inline">\(\beta\)</span> y exponente <span
class="math inline">\(e\)</span>, el error relativo en la representación
de un número real <span class="math inline">\(x\)</span>, <span
class="math inline">\(x \neq 0\)</span> es estimado por:</p>
<div class="recuadro-gris">
<p><span class="math display">\[
\left|\dfrac{x-fl(x)}{x}\right| \leq \mu
\]</span></p>
</div></li>
<li><p>donde <span class="math inline">\(\mu\)</span> se conoce como la
unidad de precisión (o redondeo) de la máquina. El valor <span
class="math inline">\(\mu\)</span> es una característica de la máquina,
su sistema operativo y el modo de calcular (simple o doble
precisión).</p></li>
<li><p>Otra definición de <span class="math inline">\(\mu \approx
\epsilon\)</span> (Epsilon de la máquina): <span
class="math inline">\(\epsilon\)</span> es el número más pequeño
positivo de la forma <span class="math inline">\(\epsilon =
2^{-k}\)</span> tal que:</p>
<div class="recuadro-gris">
<p><span class="math display">\[
1.0+\epsilon \neq 1.0 \quad \text{(en la máquina)}
\]</span></p>
</div></li>
</ul>
<pre class="python"><code># Definición de una función para calcular el épsilon de la máquina
def calcular_epsilon_maquina():
    &quot;&quot;&quot;
    Calcula el épsilon de la máquina (el número más pequeño tal que 1 + eps &gt; 1).
    &quot;&quot;&quot;
    epsilon = 1.0
    
    # Mientras 1.0 + epsilon sea reconocido como igual a 1.0,
    # dividimos epsilon a la mitad.
    while 1.0 + epsilon &gt; 1.0:
        epsilon /= 2.0
    
    # La última división hace que 1.0 + epsilon ya no sea &gt; 1.0.
    # Por lo tanto, el verdadero épsilon es el valor anterior (el doble).
    return epsilon * 2.0

# Ejecutar la función y mostrar el resultado
epsilon_calculado = calcular_epsilon_maquina()

print(&quot;---&quot;)</code></pre>
<pre><code>## ---</code></pre>
<pre class="python"><code>print(f&quot;Épsilon de la máquina (calculado): {epsilon_calculado}&quot;)</code></pre>
<pre><code>## Épsilon de la máquina (calculado): 2.220446049250313e-16</code></pre>
<pre class="python"><code>print(f&quot;En notación científica: {epsilon_calculado:.2e}&quot;)</code></pre>
<pre><code>## En notación científica: 2.22e-16</code></pre>
<pre class="python"><code>print(&quot;---&quot;)</code></pre>
<pre><code>## ---</code></pre>
<pre class="python"><code># Comprobación de la definición:
# 1 + épsilon
print(f&quot;Comprobación (1 + Épsilon): {1.0 + epsilon_calculado}&quot;)</code></pre>
<pre><code>## Comprobación (1 + Épsilon): 1.0000000000000002</code></pre>
<pre class="python"><code># 1 + épsilon / 2 (debería ser igual a 1)
print(f&quot;Comprobación (1 + Épsilon / 2): {1.0 + epsilon_calculado / 2.0}&quot;)</code></pre>
<pre><code>## Comprobación (1 + Épsilon / 2): 1.0</code></pre>
</div>
<div id="condicionamiento-y-estabillidad" class="section level2"
number="2.6">
<h2><span class="header-section-number">2.6</span> Condicionamiento y
Estabillidad</h2>
<ul>
<li>Diremos que un proceso numérico, o una operación, es inestable
cuando pequeños errores en los datos de entrada, o errores de redondeo
en alguna de las etapas el proceso, producen errores grandes en los
datos de salida.</li>
<li>Diremos que un proceso numérico, es estable cuando no es
inestable.</li>
<li>Un mismo algoritmo puede ser estable para algunos datos iniciales e
inestable para otros. Entonces se dice que el algoritmo es
condicionalmente estable.</li>
</ul>
<div id="ejemplo-6" class="section level3 caja-ejemplo" number="2.6.1">
<h3><span class="header-section-number">2.6.1</span> Ejemplo 6</h3>
<p>Nos planteamos calcular el valor <span
class="math inline">\(x_n=\frac{1}{3^n}\)</span>, donde <span
class="math inline">\(x_0=1\)</span>, <span
class="math inline">\(x_1=\frac{1}{3}\)</span>, <span
class="math inline">\(x_2=\frac{1}{9}\)</span>, y así sucesivamente.</p>
<p>Existe una fórmula recursiva para calcular <span
class="math inline">\(x_n\)</span></p>
<p><span class="math display">\[
x_{n+1} = Ax_n + \left(\dfrac{1-3A}{9}\right)x_{n-1}
\]</span> donde <span class="math inline">\(A\)</span> es una constante
fija.</p>
<ul>
<li><span class="math inline">\(\therefore\)</span> Si elegimos <span
class="math inline">\(x_1=\frac{1}{3}\approx
0.3333=\tilde{x}_1\)</span></li>
<li><span class="math inline">\(\tilde{x}_1=x_1+E_1\)</span>, donde
<span class="math inline">\(E_1\)</span> es el error de redondeo en la
representación de <span class="math inline">\(x_1\)</span>.</li>
<li>Calculamos <span class="math inline">\(x_2\)</span> usando la
fórmula recursiva:
<ul>
<li><span class="math inline">\(\tilde{x}_2 = A\tilde{x}_1 +
\left(\dfrac{1-3A}{9}\right)x_0\)</span></li>
<li><span class="math inline">\(= Ax_1 + \left(\dfrac{1-3A}{9}\right)x_0
+ AE_1\)</span></li>
<li><span class="math inline">\(= x_2 + AE_1\)</span></li>
</ul></li>
<li>Así, el error en el cálculo de <span
class="math inline">\(x_2\)</span> es <span class="math inline">\(E_2 =
AE_1\)</span>.</li>
<li>De forma similar, el error en el cálculo de <span
class="math inline">\(x_3\)</span> es <span class="math inline">\(E_3 =
AE_2 = A^2E_1\)</span>.</li>
<li>En general, el error en el cálculo de <span
class="math inline">\(x_n\)</span> es <span class="math inline">\(E_n =
A^{n-1}E_1\)</span>.</li>
<li>Si <span class="math inline">\(|A| &gt; 1\)</span>, el error crece
exponencialmente con <span class="math inline">\(n\)</span> y el proceso
es inestable.</li>
<li>Si <span class="math inline">\(|A| &lt; 1\)</span>, el error decrece
con <span class="math inline">\(n\)</span> y el proceso es estable.</li>
</ul>
<pre class="python"><code>import pandas as pd

pd.set_option(&#39;display.float_format&#39;, &#39;{:.15f}&#39;.format)

def calcular_xn_tabla(A, n, x0=1.0, x1=1/3):
    &quot;&quot;&quot;
    Calcula x_n usando la fórmula recursiva y devuelve todos los valores en una lista.
    &quot;&quot;&quot;
    # Lista para almacenar los resultados: [índice, valor]
    resultados = []
    
    # Valores iniciales
    xn_minus_2 = x0
    xn_minus_1 = x1
    
    # Almacenar x0 y x1
    resultados.append({&#39;n&#39;: 0, &#39;x_n&#39;: x0})
    resultados.append({&#39;n&#39;: 1, &#39;x_n&#39;: x1})
    
    # Calcular y almacenar desde n=2 hasta el valor deseado
    for i in range(2, n + 1):
        # Fórmula recursiva: x_n = A * x_{n-1} + ((1 - 3 * A) / 9) * x_{n-2}
        xn = A * xn_minus_1 + ((1 - 3 * A) / 9) * xn_minus_2
        
        # Almacenar el resultado de la iteración actual
        resultados.append({&#39;n&#39;: i, &#39;x_n&#39;: xn})
        
        # Actualizar variables para la próxima iteración
        xn_minus_2 = xn_minus_1
        xn_minus_1 = xn
        
    return resultados

# Parámetros
A = 4.0  # Coeficiente
n = 20   # Número máximo de iteraciones

# 1. Generar los datos
datos = calcular_xn_tabla(A, n)

# 2. Crear el DataFrame de pandas
df = pd.DataFrame(datos)

# 3. Imprimir la tabla
# La simple visualización del DataFrame de pandas genera una tabla bien formateada en R Markdown.
print(f&quot;Resultados de la recurrencia con A = {A:.15f}:&quot;)</code></pre>
<pre><code>## Resultados de la recurrencia con A = 4.000000000000000:</code></pre>
<pre class="python"><code>df</code></pre>
<pre><code>##      n                x_n
## 0    0  1.000000000000000
## 1    1  0.333333333333333
## 2    2  0.111111111111111
## 3    3  0.037037037037036
## 4    4  0.012345679012343
## 5    5  0.004115226337439
## 6    6  0.001371742112447
## 7    7  0.000457247370695
## 8    8  0.000152415789788
## 9    9  0.000050805261637
## 10  10  0.000016935081250
## 11  11  0.000005645005223
## 12  12  0.000001881588252
## 13  13  0.000000626902180
## 14  14  0.000000207889744
## 15  15  0.000000065345200
## 16  16  0.000000007293336
## 17  17 -0.000000050693010
## 18  18 -0.000000211686118
## 19  19 -0.000000784786348
## 20  20 -0.000002880417914</code></pre>
<pre class="python"><code># Parámetros
A = 0.5  # Coeficiente
n = 20   # Número máximo de iteraciones

# 1. Generar los datos
datos = calcular_xn_tabla(A, n)

# 2. Crear el DataFrame de pandas
df = pd.DataFrame(datos)

# 3. Imprimir la tabla
# La simple visualización del DataFrame de pandas genera una tabla bien formateada en R Markdown.
print(f&quot;Resultados de la recurrencia con A = {A}:&quot;)</code></pre>
<pre><code>## Resultados de la recurrencia con A = 0.5:</code></pre>
<pre class="python"><code>df</code></pre>
<pre><code>##      n               x_n
## 0    0 1.000000000000000
## 1    1 0.333333333333333
## 2    2 0.111111111111111
## 3    3 0.037037037037037
## 4    4 0.012345679012346
## 5    5 0.004115226337449
## 6    6 0.001371742112483
## 7    7 0.000457247370828
## 8    8 0.000152415790276
## 9    9 0.000050805263425
## 10  10 0.000016935087808
## 11  11 0.000005645029269
## 12  12 0.000001881676423
## 13  13 0.000000627225474
## 14  14 0.000000209075158
## 15  15 0.000000069691719
## 16  16 0.000000023230573
## 17  17 0.000000007743524
## 18  18 0.000000002581175
## 19  19 0.000000000860392
## 20  20 0.000000000286797</code></pre>
</div>
</div>
<div id="práctica-computacional" class="section level2" number="2.7">
<h2><span class="header-section-number">2.7</span> Práctica
Computacional</h2>
<p>En la el siguiente enlace <code>practica1.pdf</code> encontrará
ejercicios prácticos relacionados con el uso de python y las librerias
Numpy y matplotlob para comenzar a entender el uso de estas.</p>
<p>Descargue el PDF de la Tarea aquí:</p>
<p><a href="ejercicios1.pdf">Descargar Prácica PDF</a></p>
<hr />
<p><small>Última revisión: 26 de octubre, 2025</small></p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
