% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\documentclass[
]{article}
\usepackage{xcolor}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={Teoría de Errores},
  pdfauthor={José Luis Ramírez},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\title{Teoría de Errores}
\author{José Luis Ramírez}
\date{Octubre 2025}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{3}
\tableofcontents
}
\section{Motivación}\label{motivaciuxf3n}

\begin{itemize}
\tightlist
\item
  La gran mayoría de los modelos matemáticos que describen procesos
  físicos no pueden resolverse analíticamente.
\item
  En una situación práctica, un problema matemático deriva de un
  fenómeno físico sobre el cual se han hecho algunas suposiciones para
  simplificarlo y poderlo representar matemáticamente.
\item
  Una vez formulado el problema, deben diseñarse métodos numéricos para
  resolver el problema. La selección o construcción de los algoritmos
  apropiados cae propiamente dentro del terreno del Análisis Numérico.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Teoría de Errores y
Aproximación}\label{teoruxeda-de-errores-y-aproximaciuxf3n}

El análisis numérico proporciona métodos computacionales para el estudio
y solución de problemas matemáticos. Debido a que muchos cálculos son
realizados en computadores digitales, es conveniente la discusión para
la implementación de los métodos numéricos como programas de computador.

\begin{itemize}
\tightlist
\item
  Desafortunadamente los resultados son afectados por el uso de la
  \textbf{Aritmética de Precisión Finita}.
\item
  Esperamos tener siempre expresiones verdaderas como \(2 + 2 = 4\),
  \(3^2 = 9\), \((\sqrt{5})^2 = 5\), pero en la aritmética de precisión
  finita \(\sqrt{5}\) no tiene un solo número fijo y finito, que lo
  represente.
\end{itemize}

Los resultados numéricos están influenciados por muchos tipos de
errores, los cuales pueden ser catalogados a grandes rasgos en tres
tipos básicos:

\begin{itemize}
\tightlist
\item
  \textbf{Errores inherentes} que existen en los valores de los datos de
  entrada, ya sean causados por incertidumbre o por la naturaleza
  necesariamente aproximada de la representación.
\item
  \textbf{Errores de discretización} (llamados también de truncamiento)
  que surgen al reemplazar procesos límites por su resultado antes de
  alcanzar tal límite.
\item
  \textbf{Errores de redondeo} que se originan al utilizar una
  aritmética que involucra números con un número finito de dígitos.
\end{itemize}

\subsection{Errores Absolutos y
Relativos.}\label{errores-absolutos-y-relativos.}

Sea \(x\) el valor exacto de un número real y \(\tilde{x}\) el valor
aproximado. Contemplando todos los posibles errores, la relación entre
el resultado exacto y el aproximado es:

\[
x=\tilde{x}+E
\]

Se define el error absoluto y se denota \(E_a\) como la diferencia
\(x − \tilde{x}\), y se expresa siempre en valor absoluto.

\[
E_a = |x - \tilde{x}|
\]

Al cociente entre el error absoluto \(E_a\) y el valor real \(x\) se le
denomina error relativo y se denota por \(E_r\). Se expresa también en
valor absoluto, es decir:

\[
E_r =\dfrac{|E_a|}{|x|} = \dfrac{|x - \tilde{x}|}{|x|}
\]

\subsubsection{Ejemplo 1}\label{ejemplo-1}

\begin{itemize}
\tightlist
\item
  Calculemos los errores absolutos y relativos para el valor
  \(x= 1234.5678\), con aproximaciones a 4 dígitos \(x_1=1234\) y
  \(x_2=1235\)

  \begin{itemize}
  \tightlist
  \item
    \(E_a = |x - x_1| = |1234.5678 - 1234| = 0.5678\),
    \(E_r = \dfrac{|E_a|}{|x|} = \dfrac{0.5678}{1234.5678} \approx 5 \times 10^{-4}\).
  \item
    \(E_a = |x - x_2| = |1234.5678 - 1235| = 0.4322\),
    \(E_r = \dfrac{|E_a|}{|x|} = \dfrac{0.4322}{1234.5678} \approx 4 \times 10^{-4}\).
  \end{itemize}
\item
  Calculemos los errores absolutos y relativos para el valor
  \(x= −0.00004599881234\), con aproximaciones a 4 dígitos
  \(x_1=-0.00004599\) y \(x_2=-0.00004600\)

  \begin{itemize}
  \tightlist
  \item
    \(E_a = |x - x_1| = |−0.00004599881234 + 0.00004599| = 8.81234 \times 10^{−9}\),
    \(E_r = \dfrac{|E_a|}{|x|} = \dfrac{8.81234×10^{−9}}{0.00004599881234} \approx 2 \times 10^{-4}\).
  \item
    \(E_a = |x - x_2| = |−0.00004599881234 + 0.00004600| = 1.18766 \times 10^{−9}\),
    \(E_r = \dfrac{|E_a|}{|x|} = \dfrac{1.18766 \times 10^{−9}}{0.00004599881234} \approx 2.5819 \times 10^{-4}\).
  \end{itemize}
\end{itemize}

Observaciones:

\begin{itemize}
\item
  Mirando los ejemplos anteriores, vemos que los \textbf{errores
  absolutos} dependen de las magnitudes de los valores \(x\): en el
  primer ejemplo los errores absolutos son de orden de \(10^{−1}\); en
  cambio, en el segundo, son del orden de \(10^{−9}\).
\item
  En cambio, los \textbf{errores relativos} no se ven afectados por
  dichas magnitudes. Por dicho motivo, si queremos estudiar los errores
  sin tener en cuenta el orden de los valores \(x\), hay que usar los
  \textbf{errores relativos}. Vemos que en los dos ejemplos los errores
  relativos son del orden de \(10^{−4}\). ya que recordemos que las
  aproxi9maciones son a 4 \textbf{cifras decimales significativas}.
\end{itemize}

\subsection{Cifras Significativas.}\label{cifras-significativas.}

Se dice que el número \(\tilde{x}\) aproxima al número \(x\) con \(t\)
dígitos (o cifras) significativas, si \(t\) es el número entero más
grande no negativo para el cual:

\[E_r<0.5\times10^{-t} \Rightarrow \dfrac{|x - \tilde{x}|}{|x|} < 0.5 \times 10^{-t}\]

\subsubsection{Ejemplo 2}\label{ejemplo-2}

Sea \(\tilde{x} = 3.1416\) una aproximación al valor \(\pi\), y
\(x = 3.1415927\) una mejor aproximación.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ math}
\ImportTok{import}\NormalTok{ string}
\ImportTok{from}\NormalTok{ decimal }\ImportTok{import}\NormalTok{ Decimal}

\KeywordTok{def}\NormalTok{ redondear(N,signif):}
  \CommentTok{"""}
\CommentTok{      Dado un número real N y un número determinado de cifras significativas signif,}
\CommentTok{      nos da la aproximación de este número con signif cifras significativas.}

\CommentTok{        Parámetros:}
\CommentTok{        * N: número decimal}
\CommentTok{        * signif: número de digitos representativos}

\CommentTok{        Valor de retorno}
\CommentTok{        * número redondeado a signif número de cifras significativas}

\CommentTok{   """}
  \ControlFlowTok{if} \BuiltInTok{int}\NormalTok{(N)}\OperatorTok{==}\DecValTok{0}\NormalTok{:}
    \ControlFlowTok{return} \BuiltInTok{float}\NormalTok{(}\BuiltInTok{round}\NormalTok{(Decimal(}\BuiltInTok{str}\NormalTok{(N)),signif))}
  \ControlFlowTok{else}\NormalTok{:}
    \ControlFlowTok{return} \BuiltInTok{float}\NormalTok{(}\BuiltInTok{round}\NormalTok{(Decimal(}\BuiltInTok{str}\NormalTok{(N)),signif}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{{-}}\BuiltInTok{int}\NormalTok{(math.log(}\BuiltInTok{abs}\NormalTok{(N),}\DecValTok{10}\NormalTok{))))}
  
\KeywordTok{def}\NormalTok{ Err(num,dig):}
    \CommentTok{"""}
\CommentTok{      Dado un número real y un número determinado de cifras significativas,}
\CommentTok{      nos da el error absoluto y relativo de dicho número.}

\CommentTok{        Parámetros:}
\CommentTok{        * num: número decimal}
\CommentTok{        * dig: número de cifras significativas}

\CommentTok{        Valor de retorno}
\CommentTok{        * Error absoluto}
\CommentTok{        * Error Relativo}

\CommentTok{    """}
\NormalTok{    err\_abs}\OperatorTok{=}\BuiltInTok{abs}\NormalTok{(num}\OperatorTok{{-}}\NormalTok{redondear(num,dig))}
\NormalTok{    err\_rel}\OperatorTok{=}\NormalTok{err\_abs}\OperatorTok{/}\BuiltInTok{abs}\NormalTok{(redondear(num,dig))}

    \BuiltInTok{print}\NormalTok{(}\StringTok{"El error absoluto es }\SpecialCharTok{\{\}}\StringTok{"}\NormalTok{.}\BuiltInTok{format}\NormalTok{(err\_abs))}
    \BuiltInTok{print}\NormalTok{(}\StringTok{"El error relativo es }\SpecialCharTok{\{\}}\StringTok{"}\NormalTok{.}\BuiltInTok{format}\NormalTok{(err\_rel))}

    \ControlFlowTok{return}\NormalTok{ (err\_abs, err\_rel)}

\NormalTok{Err(}\FloatTok{3.1415927}\NormalTok{,}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## El error absoluto es 7.300000000043383e-06
## El error relativo es 2.3236567354352506e-06
## (7.300000000043383e-06, 2.3236567354352506e-06)
\end{verbatim}

\[
\begin{align*}
E_a & = |x - \tilde{x}| = |3.1415927 - 3.1416| = 0.0000073 \\
E_r & = \dfrac{|E_a|}{|x|} = \dfrac{0.0000073}{3.1415927} \approx 0.232 \times 10^{-5}< 0.5 \times 10^{-5}
\end{align*}
\] Luego, \(\tilde{x}\) aproxima a \(\pi\) con 5 cifras significativas.

\subsection{Aproximación de
Números.}\label{aproximaciuxf3n-de-nuxfameros.}

Sea \(x = a_n\ldots a_0.b_1b_2\ldots \in \mathbb{R}\) (En cualquier
base), para aproximar hasta el \(t\)-ésimo decimal:

\begin{itemize}
\tightlist
\item
  Por \textbf{truncamiento}

  \[
  \tilde{x}_{trunc} = a_n\ldots a_0.b_1b_2\ldots b_t
  \]
\item
  Por \textbf{redondeo correcto}

  \[
  \tilde{x}_{redon} = \begin{cases}
  a_n\ldots a_0.b_1b_2\ldots b_t & \text{si } b_{t+1} < 5 \\
  a_n\ldots a_0.b_1b_2\ldots b_t + \beta^{-t} & \text{si } b_{t+1} \geq 5
  \end{cases}
  \]
\end{itemize}

\subsection{Forma Normalizada de Números en Punto
Flotante}\label{forma-normalizada-de-nuxfameros-en-punto-flotante}

Un número en punto flotante en base \(\beta\) con precisión \(t\) es un
número que puede representarse en la forma:

\[x = \sigma (0.d_1d_2\ldots d_t)_{\beta} \times \beta^e\]

donde:

\begin{itemize}
\tightlist
\item
  \(\sigma\) es el signo del número (\(+1\) o \(-1\)),
\item
  \(d_1d_2\ldots d_t\) son los dígitos en base \(\beta\) (con
  \(0 \leq d_i < \beta\) y \(d_1 \neq 0\) para la forma normalizada),
\item
  \(e\) es el exponente entero, y es tal que \(L \geq e \geq U\) para
  ciertos enteros \(L\) y \(U\).
\item
  \(t\) es la precisión (número de dígitos significativos).
\end{itemize}

Una de las características de todo conjunto de punto flotante \(F\) es
que es finito y tiene:

\[
2(\beta - 1)\beta^{t-1}(U - L + 1) + 1
\]

números diferentes (incluyendo el cero), y donde los distintos de cero
están en forma normalizada.

\subsubsection{Ejemplo 3}\label{ejemplo-3}

Sea el conjunto de punto flotante \(F\) con parámetros
\(\beta = 2\)(Binario), \(t = 3\), \(L = -2\), \(U = 2\). Tal conjunto
\(F\) tiene

\[2(2 - 1)2^{3 - 1}(2 - (-2) + 1) + 1 = 41\]

números diferentes (incluyendo el cero). La lista completa de números en
\(F\) es:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\KeywordTok{def}\NormalTok{ generar\_punto\_flotante(beta, t, L, U):}
\NormalTok{    numeros }\OperatorTok{=} \BuiltInTok{set}\NormalTok{()}
    \ControlFlowTok{for}\NormalTok{ signo }\KeywordTok{in}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\OperatorTok{{-}}\DecValTok{1}\NormalTok{]:}
        \ControlFlowTok{for}\NormalTok{ exponente }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(L, U }\OperatorTok{+} \DecValTok{1}\NormalTok{):}
            \ControlFlowTok{for}\NormalTok{ d1 }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{1}\NormalTok{, beta):}
                \ControlFlowTok{for}\NormalTok{ d2 }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(beta):}
                    \ControlFlowTok{for}\NormalTok{ d3 }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(beta):}
\NormalTok{                        numero }\OperatorTok{=}\NormalTok{ signo }\OperatorTok{*}\NormalTok{ (d1 }\OperatorTok{*}\NormalTok{ beta}\OperatorTok{**}\NormalTok{(}\OperatorTok{{-}}\DecValTok{1}\NormalTok{) }\OperatorTok{+}\NormalTok{ d2 }\OperatorTok{*}\NormalTok{ beta}\OperatorTok{**}\NormalTok{(}\OperatorTok{{-}}\DecValTok{2}\NormalTok{) }\OperatorTok{+}\NormalTok{ d3 }\OperatorTok{*}\NormalTok{ beta}\OperatorTok{**}\NormalTok{(}\OperatorTok{{-}}\DecValTok{3}\NormalTok{)) }\OperatorTok{*}\NormalTok{ (beta }\OperatorTok{**}\NormalTok{ exponente)}
\NormalTok{                        numeros.add(}\BuiltInTok{round}\NormalTok{(numero, }\DecValTok{10}\NormalTok{))  }\CommentTok{\# Redondear para evitar problemas de precisión}
\NormalTok{    numeros.add(}\DecValTok{0}\NormalTok{)  }\CommentTok{\# Incluir el cero}
    \ControlFlowTok{return} \BuiltInTok{sorted}\NormalTok{(numeros)}

\CommentTok{\# Parámetros del sistema de punto flotante}
\NormalTok{beta }\OperatorTok{=} \DecValTok{2}  \CommentTok{\# Base (binaria)}
\NormalTok{t }\OperatorTok{=} \DecValTok{3}     \CommentTok{\# Dígitos de la mantisa}
\NormalTok{L }\OperatorTok{=} \OperatorTok{{-}}\DecValTok{2}    \CommentTok{\# Exponente mínimo}
\NormalTok{U }\OperatorTok{=} \DecValTok{2}     \CommentTok{\# Exponente máximo}
\NormalTok{punto\_flotante }\OperatorTok{=}\NormalTok{ generar\_punto\_flotante(beta, t, L, U)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Números en el conjunto de punto flotante F:}\SpecialCharTok{\{\}}\StringTok{"}\NormalTok{.}\BuiltInTok{format}\NormalTok{(punto\_flotante))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Números en el conjunto de punto flotante F:[-3.5, -3.0, -2.5, -2.0, -1.75, -1.5, -1.25, -1.0, -0.875, -0.75, -0.625, -0.5, -0.4375, -0.375, -0.3125, -0.25, -0.21875, -0.1875, -0.15625, -0.125, 0, 0.125, 0.15625, 0.1875, 0.21875, 0.25, 0.3125, 0.375, 0.4375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.25, 1.5, 1.75, 2.0, 2.5, 3.0, 3.5]
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# {-}{-}{-} Visualización de la Recta Real y los Puntos {-}{-}{-}}
\NormalTok{plt.figure(figsize}\OperatorTok{=}\NormalTok{(}\DecValTok{12}\NormalTok{, }\DecValTok{2}\NormalTok{)) }\CommentTok{\# Ajusta el tamaño de la figura (ancho, alto)}

\CommentTok{\# Dibuja la recta real (una línea horizontal)}
\NormalTok{plt.axhline(}\DecValTok{0}\NormalTok{, color}\OperatorTok{=}\StringTok{\textquotesingle{}gray\textquotesingle{}}\NormalTok{, linestyle}\OperatorTok{=}\StringTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{, linewidth}\OperatorTok{=}\DecValTok{1}\NormalTok{) }

\CommentTok{\# Dibuja los puntos generados sobre la recta \textquotesingle{}o\textquotesingle{} para los marcadores, \textquotesingle{}b\textquotesingle{} para el color azul, markersize para el tamaño}
\NormalTok{plt.plot(punto\_flotante, np.zeros\_like(punto\_flotante), }\StringTok{\textquotesingle{}ob\textquotesingle{}}\NormalTok{, markersize}\OperatorTok{=}\DecValTok{5}\NormalTok{)}
\NormalTok{plt.plot(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\StringTok{\textquotesingle{}go\textquotesingle{}}\NormalTok{, markersize}\OperatorTok{=}\DecValTok{7}\NormalTok{, label}\OperatorTok{=}\StringTok{\textquotesingle{}Cero\textquotesingle{}}\NormalTok{) }\CommentTok{\# \textquotesingle{}go\textquotesingle{} = green circle}

\CommentTok{\# Etiquetas y Título}
\NormalTok{plt.title(}\SpecialStringTok{f\textquotesingle{}Representación de Números de Punto Flotante (beta=}\SpecialCharTok{\{}\NormalTok{beta}\SpecialCharTok{\}}\SpecialStringTok{, t=}\SpecialCharTok{\{}\NormalTok{t}\SpecialCharTok{\}}\SpecialStringTok{, L=}\SpecialCharTok{\{}\NormalTok{L}\SpecialCharTok{\}}\SpecialStringTok{, U=}\SpecialCharTok{\{}\NormalTok{U}\SpecialCharTok{\}}\SpecialStringTok{)\textquotesingle{}}\NormalTok{)}
\NormalTok{plt.xlabel(}\StringTok{\textquotesingle{}Recta Real\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Ajustes de los ejes para que los puntos sean más visibles}
\NormalTok{min\_val }\OperatorTok{=} \BuiltInTok{min}\NormalTok{(punto\_flotante) }\OperatorTok{{-}} \FloatTok{0.5}
\NormalTok{max\_val }\OperatorTok{=} \BuiltInTok{max}\NormalTok{(punto\_flotante) }\OperatorTok{+} \FloatTok{0.5}
\NormalTok{x\_limits }\OperatorTok{=}\NormalTok{ plt.xlim(min\_val, max\_val) }\CommentTok{\# Extiende ligeramente los límites del eje X}
\NormalTok{yticks }\OperatorTok{=}\NormalTok{ plt.yticks([]) }\CommentTok{\# Oculta las marcas del eje Y, ya que solo es una recta horizontal}

\CommentTok{\# Muestra una leyenda si es necesario}
\NormalTok{plt.legend()}
\NormalTok{plt.grid(}\VariableTok{True}\NormalTok{, linestyle}\OperatorTok{=}\StringTok{\textquotesingle{}:\textquotesingle{}}\NormalTok{, alpha}\OperatorTok{=}\FloatTok{0.7}\NormalTok{)}
\NormalTok{plt.show()}
\end{Highlighting}
\end{Shaded}

\pandocbounded{\includegraphics[keepaspectratio]{unidad01_files/figure-latex/unnamed-chunk-2-3.pdf}}

\begin{itemize}
\tightlist
\item
  Hay un rango limitado para representar cantidades

  \begin{itemize}
  \tightlist
  \item
    Hay números grandes positivos y negativos que no pueden ser
    representados (overflow)
  \item
    No pueden representarse números muy pequeños (underflow)
  \end{itemize}
\item
  Hay sólo un número finito de cantidades que puede ser representado
  dentro de un rango

  \begin{itemize}
  \tightlist
  \item
    El grado de precisión es limitado
  \item
    Para aquellos que no pueden ser representados exactamente, la
    aproximación real se puede lograr: truncando o redondeando.
  \end{itemize}
\item
  El intervalo entre números aumenta tanto como los números crecen en
  magnitud

  \begin{itemize}
  \tightlist
  \item
    El error cuantificable más grande ocurrirá para aquellos valores que
    caigan justo debajo del límite superior de la primera serie de
    intervalos igualmente espaciados.
  \end{itemize}
\end{itemize}

Vamos a ver cómo se almacena un número real en el ordenador en
\textbf{formato binario} usando \textbf{64 bits}.

Sea \(x\) un número real que suponemos en formato \textbf{binario}.

Escribimos \(x\) de la forma siguiente:

\[
x=(−1)^s 1.f\times2^{c−1023},
\]

donde

\begin{itemize}
\tightlist
\item
  \(s\) indica el signo del número, indicado \(s=0\) para los números
  positivos y \(s=1\), para los negativos.
\item
  \(1.f\) es lo que se llama la mantisa donde \(f\) es una secuencia de
  ceros y unos, es decir,

  \[
  f= f_1f_2f_3\ldots f_n, \quad f_i \in \{0,1\}
  \]
\item
  \(c \geq 1\) indica el exponente del número donde se le resta 1023
  para poder representar números muy pequeños en valor absoluto.
  Escribimos \(c−1023\) en binario como \(c−1023=e_1e_2\ldots e_m\), con
  \(e_i \in \{0,1\}\)
\end{itemize}

Representamos \(x\) por tres cajas: el signo \(s\), la mantisa \(f\) y
el exponente \(c−1023\) en binario:

\[
|s| f_1f_2\ldots f_n| e_1e_2\ldots e_m|
\]

\subsubsection{Ejemplo 4:}\label{ejemplo-4}

Representar el número \(x=31.53173828125\) en formato de punto flotante
de 64 bits. \[
\begin{align*}
1. & \text{ Determinar el signo } s: \text{ Como } x > 0, \text{ entonces } s = 0. \\
2. & \text{ Convertir } x \text{ a binario: } \\
   & \quad \text{Parte entera: } 31_{10} = 11111_2. \\
   & \quad \text{Parte fraccionaria: } 0.53173828125_{10} = 0.10001000001_2. \\
   & \quad \text{Por lo tanto, } x \text{ en binario es aproximadamente } 11111.10001000001_2. \\
3. & \text{ Normalizar el número: } \\
   & \quad 11111.10001000001_2. = 1.111110001000001_2 \times 2^4. \\
4. & \text{ Determinar la mantisa } f: \\
   & \quad f = 111110001000001 \\
5. & \text{ Determinar el exponente } c - 1023: \\
   & \quad c = 4 + 1023 = 1027. \\
   & \quad \text{Convertir } 1027 \text{ a binario: } 1027_{10} = 10000000011_2. \\
6. & \text{ Representar el número en formato de 64 bits: } \\
   & \quad |0|111110001000001|10000000011|. \\
\end{align*}
\] Como sólo tenemos 64 bits para representar el número, la cantidad de
bits usados para su representación no puede superar 64

En caso que los superase, tendremos que considerar una aproximación del
mismo.

En el ejemplo se usado el número siguiente de bits:

\begin{itemize}
\tightlist
\item
  signo: 1 bit,
\item
  mantisa: 15 bits,
\item
  exponente: 11 bits,
\end{itemize}

en total, 27 bits, por tanto, sí sería posible su representación exacta
y no haría falta considerar una aproximación del mismo.

\subsubsection{Ejemplo 5:}\label{ejemplo-5}

Hagamos la conversión contraria.

Imaginemos que nos dan el número siguiente: \[
|1| 101101110011| 1111|.
\] Vamos a ver a qué número \(x\) corresponde.

El signo es negativo, por tanto \(x<0\)

La mantisa será: \[
1.f=1+\frac{1}{2}+\frac{1}{2^3}+\frac{1}{2^4}+\frac{1}{2^6}+\frac{1}{2^7}+\frac{1}{2^8}+\frac{1}{2^{11}}+\frac{1}{2^{12}}=1.7155762.
\] El exponente \(c\) vale \(1111_{2}−1023=1+2+2^2+2^3−1023=−1008\).

El número será: \[
x=−1.7155762\times2^{−1008} \approx −6.25424\times10^{−304}.
\]

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{itemize}
\tightlist
\item
  La combinación aritmética usual \(+, −, \times, \div\) de dos números
  de punto flotante no siempre produce un número de punto flotante.
\item
  Supongamos que \(fl(x), fl(y) \in F\). Veamos, como ejemplo, que la
  suma usual \(fl(x) + fl(y)\) no necesariamente será un número en
  \(F\).

  \begin{itemize}
  \tightlist
  \item
    Sea el conjunto \(F\) dado en el ejemplo: \(fl(x) = 5/32 \in F\),
    \(fl(y) = 48/32 \in F\), sin embargo
    \(fl(x) + fl(y) = 5/32 + 48/32 = 53/32 \notin F\).
  \end{itemize}
\item
  Las operaciones aritméticas que realiza un computador no corresponden
  de forma exacta con las operaciones usuales. El estudio de lo que
  ocurre realmente es difı́cil de realiza y en todo caso depende de la
  máquina que se esté utilizand.o
\item
  Denotando por \(\oplus, \ominus, \otimes, \oslash\) las operaciones de
  suma, resta, multiplicación y división de la máquina. Se definen estas
  operaciones por:

  \[
  \begin{align*}
  x \oplus y & = fl(fl(x) + fl(y))\\
  x \ominus y & = fl(fl(x) - fl(y))\\
  x \otimes y & = fl(fl(x) \times fl(y))\\
  x \oslash y & = fl(fl(x)/fl(y))
  \end{align*}
  \]
\end{itemize}

\subsection{Unidad de Precisión o
Redondeo}\label{unidad-de-precisiuxf3n-o-redondeo}

\begin{itemize}
\tightlist
\item
  En la representación en punto flotante con \(n\) dígitos en bas
  \(\beta\) y exponente \(e\), el error relativo en la representación de
  un número real \(x\), \(x \neq 0\) es estimado por:

  \[
  \left|\dfrac{x-fl(x)}{x}\right| \leq \mu
  \]
\item
  donde \(\mu\) se conoce como la unidad de precisión (o redondeo) de la
  máquina. El valor \(\mu\) es una característica de la máquina, su
  sistema operativo y el modo de calcular (simple o doble precisión).
\item
  Otra definición de \(\mu \approx \epsilon\) (Epsilon de la máquina):
  \(\epsilon\) es el número más pequeño positivo de la forma
  \(\epsilon = 2^{-k}\) tal que:

  \[
  1.0+\epsilon \neq 1.0 \quad \text{(en la máquina)}
  \]
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Definición de una función para calcular el épsilon de la máquina}
\KeywordTok{def}\NormalTok{ calcular\_epsilon\_maquina():}
    \CommentTok{"""}
\CommentTok{    Calcula el épsilon de la máquina (el número más pequeño tal que 1 + eps \textgreater{} 1).}
\CommentTok{    """}
\NormalTok{    epsilon }\OperatorTok{=} \FloatTok{1.0}
    
    \CommentTok{\# Mientras 1.0 + epsilon sea reconocido como igual a 1.0,}
    \CommentTok{\# dividimos epsilon a la mitad.}
    \ControlFlowTok{while} \FloatTok{1.0} \OperatorTok{+}\NormalTok{ epsilon }\OperatorTok{\textgreater{}} \FloatTok{1.0}\NormalTok{:}
\NormalTok{        epsilon }\OperatorTok{/=} \FloatTok{2.0}
    
    \CommentTok{\# La última división hace que 1.0 + epsilon ya no sea \textgreater{} 1.0.}
    \CommentTok{\# Por lo tanto, el verdadero épsilon es el valor anterior (el doble).}
    \ControlFlowTok{return}\NormalTok{ epsilon }\OperatorTok{*} \FloatTok{2.0}

\CommentTok{\# Ejecutar la función y mostrar el resultado}
\NormalTok{epsilon\_calculado }\OperatorTok{=}\NormalTok{ calcular\_epsilon\_maquina()}

\BuiltInTok{print}\NormalTok{(}\StringTok{"{-}{-}{-}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## ---
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Épsilon de la máquina (calculado): }\SpecialCharTok{\{}\NormalTok{epsilon\_calculado}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Épsilon de la máquina (calculado): 2.220446049250313e-16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"En notación científica: }\SpecialCharTok{\{}\NormalTok{epsilon\_calculado}\SpecialCharTok{:.2e\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## En notación científica: 2.22e-16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{print}\NormalTok{(}\StringTok{"{-}{-}{-}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## ---
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Comprobación de la definición:}
\CommentTok{\# 1 + épsilon}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Comprobación (1 + Épsilon): }\SpecialCharTok{\{}\FloatTok{1.0} \OperatorTok{+}\NormalTok{ epsilon\_calculado}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Comprobación (1 + Épsilon): 1.0000000000000002
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# 1 + épsilon / 2 (debería ser igual a 1)}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Comprobación (1 + Épsilon / 2): }\SpecialCharTok{\{}\FloatTok{1.0} \OperatorTok{+}\NormalTok{ epsilon\_calculado }\OperatorTok{/} \FloatTok{2.0}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Comprobación (1 + Épsilon / 2): 1.0
\end{verbatim}

\subsection{Condicionamiento y
Estabillidad}\label{condicionamiento-y-estabillidad}

\begin{itemize}
\tightlist
\item
  Diremos que un proceso numérico, o una operación, es inestable cuando
  pequeños errores en los datos de entrada, o errores de redondeo en
  alguna de las etapas el proceso, producen errores grandes en los datos
  de salida.
\item
  Diremos que un proceso numérico, es estable cuando no es inestable.
\item
  Un mismo algoritmo puede ser estable para algunos datos iniciales e
  inestable para otros. Entonces se dice que el algoritmo es
  condicionalmente estable.
\end{itemize}

\subsubsection{Ejemplo 6}\label{ejemplo-6}

Nos planteamos calcular el valor \(x_n=\frac{1}{3^n}\), donde \(x_0=1\),
\(x_1=\frac{1}{3}\), \(x_2=\frac{1}{9}\), y así sucesivamente.

Existe una fórmula recursiva para calcular \(x_n\)

\[
x_{n+1} = Ax_n + \left(\dfrac{1-3A}{9}\right)x_{n-1}
\] donde \(A\) es una constante fija.

\begin{itemize}
\tightlist
\item
  \(\therefore\) Si elegimos
  \(x_1=\frac{1}{3}\approx 0.3333=\tilde{x}_1\)
\item
  \(\tilde{x}_1=x_1+E_1\), donde \(E_1\) es el error de redondeo en la
  representación de \(x_1\).
\item
  Calculamos \(x_2\) usando la fórmula recursiva:

  \begin{itemize}
  \tightlist
  \item
    \(\tilde{x}_2 = A\tilde{x}_1 + \left(\dfrac{1-3A}{9}\right)x_0\)
  \item
    \(= Ax_1 + \left(\dfrac{1-3A}{9}\right)x_0 + AE_1\)
  \item
    \(= x_2 + AE_1\)
  \end{itemize}
\item
  Así, el error en el cálculo de \(x_2\) es \(E_2 = AE_1\).
\item
  De forma similar, el error en el cálculo de \(x_3\) es
  \(E_3 = AE_2 = A^2E_1\).
\item
  En general, el error en el cálculo de \(x_n\) es \(E_n = A^{n-1}E_1\).
\item
  Si \(|A| > 1\), el error crece exponencialmente con \(n\) y el proceso
  es inestable.
\item
  Si \(|A| < 1\), el error decrece con \(n\) y el proceso es estable.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}

\NormalTok{pd.set\_option(}\StringTok{\textquotesingle{}display.float\_format\textquotesingle{}}\NormalTok{, }\StringTok{\textquotesingle{}}\SpecialCharTok{\{:.15f\}}\StringTok{\textquotesingle{}}\NormalTok{.}\BuiltInTok{format}\NormalTok{)}

\KeywordTok{def}\NormalTok{ calcular\_xn\_tabla(A, n, x0}\OperatorTok{=}\FloatTok{1.0}\NormalTok{, x1}\OperatorTok{=}\DecValTok{1}\OperatorTok{/}\DecValTok{3}\NormalTok{):}
    \CommentTok{"""}
\CommentTok{    Calcula x\_n usando la fórmula recursiva y devuelve todos los valores en una lista.}
\CommentTok{    """}
    \CommentTok{\# Lista para almacenar los resultados: [índice, valor]}
\NormalTok{    resultados }\OperatorTok{=}\NormalTok{ []}
    
    \CommentTok{\# Valores iniciales}
\NormalTok{    xn\_minus\_2 }\OperatorTok{=}\NormalTok{ x0}
\NormalTok{    xn\_minus\_1 }\OperatorTok{=}\NormalTok{ x1}
    
    \CommentTok{\# Almacenar x0 y x1}
\NormalTok{    resultados.append(\{}\StringTok{\textquotesingle{}n\textquotesingle{}}\NormalTok{: }\DecValTok{0}\NormalTok{, }\StringTok{\textquotesingle{}x\_n\textquotesingle{}}\NormalTok{: x0\})}
\NormalTok{    resultados.append(\{}\StringTok{\textquotesingle{}n\textquotesingle{}}\NormalTok{: }\DecValTok{1}\NormalTok{, }\StringTok{\textquotesingle{}x\_n\textquotesingle{}}\NormalTok{: x1\})}
    
    \CommentTok{\# Calcular y almacenar desde n=2 hasta el valor deseado}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{2}\NormalTok{, n }\OperatorTok{+} \DecValTok{1}\NormalTok{):}
        \CommentTok{\# Fórmula recursiva: x\_n = A * x\_\{n{-}1\} + ((1 {-} 3 * A) / 9) * x\_\{n{-}2\}}
\NormalTok{        xn }\OperatorTok{=}\NormalTok{ A }\OperatorTok{*}\NormalTok{ xn\_minus\_1 }\OperatorTok{+}\NormalTok{ ((}\DecValTok{1} \OperatorTok{{-}} \DecValTok{3} \OperatorTok{*}\NormalTok{ A) }\OperatorTok{/} \DecValTok{9}\NormalTok{) }\OperatorTok{*}\NormalTok{ xn\_minus\_2}
        
        \CommentTok{\# Almacenar el resultado de la iteración actual}
\NormalTok{        resultados.append(\{}\StringTok{\textquotesingle{}n\textquotesingle{}}\NormalTok{: i, }\StringTok{\textquotesingle{}x\_n\textquotesingle{}}\NormalTok{: xn\})}
        
        \CommentTok{\# Actualizar variables para la próxima iteración}
\NormalTok{        xn\_minus\_2 }\OperatorTok{=}\NormalTok{ xn\_minus\_1}
\NormalTok{        xn\_minus\_1 }\OperatorTok{=}\NormalTok{ xn}
        
    \ControlFlowTok{return}\NormalTok{ resultados}

\CommentTok{\# Parámetros}
\NormalTok{A }\OperatorTok{=} \FloatTok{4.0}  \CommentTok{\# Coeficiente}
\NormalTok{n }\OperatorTok{=} \DecValTok{20}   \CommentTok{\# Número máximo de iteraciones}

\CommentTok{\# 1. Generar los datos}
\NormalTok{datos }\OperatorTok{=}\NormalTok{ calcular\_xn\_tabla(A, n)}

\CommentTok{\# 2. Crear el DataFrame de pandas}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(datos)}

\CommentTok{\# 3. Imprimir la tabla}
\CommentTok{\# La simple visualización del DataFrame de pandas genera una tabla bien formateada en R Markdown.}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Resultados de la recurrencia con A = }\SpecialCharTok{\{}\NormalTok{A}\SpecialCharTok{:.15f\}}\SpecialStringTok{:"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Resultados de la recurrencia con A = 4.000000000000000:
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      n                x_n
## 0    0  1.000000000000000
## 1    1  0.333333333333333
## 2    2  0.111111111111111
## 3    3  0.037037037037036
## 4    4  0.012345679012343
## 5    5  0.004115226337439
## 6    6  0.001371742112447
## 7    7  0.000457247370695
## 8    8  0.000152415789788
## 9    9  0.000050805261637
## 10  10  0.000016935081250
## 11  11  0.000005645005223
## 12  12  0.000001881588252
## 13  13  0.000000626902180
## 14  14  0.000000207889744
## 15  15  0.000000065345200
## 16  16  0.000000007293336
## 17  17 -0.000000050693010
## 18  18 -0.000000211686118
## 19  19 -0.000000784786348
## 20  20 -0.000002880417914
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Parámetros}
\NormalTok{A }\OperatorTok{=} \FloatTok{0.5}  \CommentTok{\# Coeficiente}
\NormalTok{n }\OperatorTok{=} \DecValTok{20}   \CommentTok{\# Número máximo de iteraciones}

\CommentTok{\# 1. Generar los datos}
\NormalTok{datos }\OperatorTok{=}\NormalTok{ calcular\_xn\_tabla(A, n)}

\CommentTok{\# 2. Crear el DataFrame de pandas}
\NormalTok{df }\OperatorTok{=}\NormalTok{ pd.DataFrame(datos)}

\CommentTok{\# 3. Imprimir la tabla}
\CommentTok{\# La simple visualización del DataFrame de pandas genera una tabla bien formateada en R Markdown.}
\BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Resultados de la recurrencia con A = }\SpecialCharTok{\{}\NormalTok{A}\SpecialCharTok{\}}\SpecialStringTok{:"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Resultados de la recurrencia con A = 0.5:
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      n               x_n
## 0    0 1.000000000000000
## 1    1 0.333333333333333
## 2    2 0.111111111111111
## 3    3 0.037037037037037
## 4    4 0.012345679012346
## 5    5 0.004115226337449
## 6    6 0.001371742112483
## 7    7 0.000457247370828
## 8    8 0.000152415790276
## 9    9 0.000050805263425
## 10  10 0.000016935087808
## 11  11 0.000005645029269
## 12  12 0.000001881676423
## 13  13 0.000000627225474
## 14  14 0.000000209075158
## 15  15 0.000000069691719
## 16  16 0.000000023230573
## 17  17 0.000000007743524
## 18  18 0.000000002581175
## 19  19 0.000000000860392
## 20  20 0.000000000286797
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Última revisión: 25 de octubre, 2025

\end{document}
