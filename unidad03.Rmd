---
title: "Solución Numérica de Ecuaciones No Lineales"
author: "José Luis Ramírez"
date: "Noviembre 2025"
output:
  html_document:
    self_contained: true
    mathjax: default
    pandoc_args: "--mathjax"
    toc: true
    toc_depth: 4
    toc_float: true
    theme: readable
    css: css/estilos.css
    number_sections: true
---

# Motivación

* La determinación de las raíces de una ecuación o de un sistema de ecuaciones, es uno de los problemas más antiguos de aproximación numérica que se presenta con frecuencia en la solución de una gran variedad de problemas en la matemática aplicada.

* En muchos problemas de ingeniería, inteligencia artificial u otras disciplinas afines tenemos que resolver ecuaciones del tipo $f(x)=0$, donde $f$ es una función que dada una cantidad $x$, nos devuelve $f(x)$.

::: caja-ejemplo
#### Ejemplo 1

Se considera por ejemplo la siguiente ecuación obtenida a partir de la segunda ley de Newton para calcular la velocidad de un paracaidista,
$$
v=\dfrac{g \cdot m}{c}\left(1-e^{\frac{c}{m}t}\right)
$$
donde la velocidad $v$ depende de la variable independiente tiempo, $t$, $g$ es la constante de gravitación, $c$ el coeficiente de resistencia y $m$ es la masa del paracaidista.

Si se quisiera obtener el coeficiente de resistencia del paracaidista con una masa dada, ¿cómo se obtendría este valor para alcanzar una velocidad determinada en un periodo establecido? La respuesta se obtendría calculando $c$ que hace cero a la siguiente función:
$$
f(c) = \dfrac{g \cdot m}{c}\left(1-e^{\frac{c}{m}t}\right)-v
$$

esto es, habría que calcular el valor de $c$ tal que $f(c)=0$.

En este caso no es posible encontrar analíticamente el cero de la función o su cálculo es complicado.
:::

* En dichos problemas, conocer explícitamente la función $f$ en muchos casos no es posible, sólo tenemos un algoritmo que dado un valor $x$, nos devuelve $f(x)$.

* Entonces, dependiendo de nuestro conocimiento de la función $f$, podremos aplicar un método numérico u otro.

* Todos los métodos numéricos que hallan aproximaciones de ceros construyen una **sucesión** $\{x_n\}_n$ que queremos que converja hacia el cero $\hat{x}$ de la función $f$.

* Cuanto mayor sea la **velocidad de convergencia** de la sucesión $\{x_n\}_n$, mejor será el método usado.

## Método Gráfico

El método gráfico es un método muy simple, consiste en calcular valores de la variable dependiente para distintos valores de la variable independiente, para luego observar el punto de intersección de la función con el eje de las abscisas. Este punto proporciona una primera aproximación a la raíz de la ecuación.

```{python, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt

# 1. Se define la función a graficar
def f(x):
  return x**2 - 4 * np.sin(x)

# 2. Se crea un conjunto de puntos en el intervalo [-2, 3]
x = np.linspace(-2, 3, 500)

# 3. Se evalúa la función en cada punto
y = f(x)

# 4. Se procede a la graficación
plt.figure(figsize=(10, 6))
plt.plot(x, y, label='f(x) = $x^2 - 4sin(x)$', color='blue')

# Se añade una línea en y=0 para identificar visualmente las raíces
plt.axhline(0, color='red', linestyle='--', linewidth=0.8)

# Se agregan detalles al gráfico para una mejor interpretación
plt.title('Gráfica de la función $f(x) = x^2 - 4sin(x)$')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.legend()

# 5. Se muestra el gráfico
plt.show()
```

# Velocidad de convergencia

Se distinguen distintas velocidades de convergencia que se pasarán a definir.

::: caja-lema
**Definición:**

Dada una sucesión de números reales, $\left\{x _k\right\}_{k = 1}^{\infty}$, convergente hacia un punto $\overline x$, se dice que su orden o velocidad de convergencia es $p$, con $p \ge 1$ si existe una constante $C_p \ge 0$ tal que: 

::: recuadro-gris
$$\left| {{x_{k + 1}} - \overline x }
\right| \le {C_p}{\left| {{x_k} - \overline x \,} \right|^p}
$$
:::

para todo $k \ge k_0$ siendo $k_0$ entero.
:::

En particular,

* Si $p=1$ y $C_p< 1$, la convergencia es **lineal**. Si $C_p \ge 1$, la convergencia es **sublineal**.

* Si $p=2$, la convergencia es **cuadrática**.

* Si $p=3$, la convergencia es **cúbica**.

::: caja-ejemplo
#### Ejemplo 2
Se considera la sucesión ${x_k} = \frac{1}{6} - \frac{1}{3}{\left(-\frac{1}{2}\right)^k}$ que converge a $\frac{1}{6}$. Se ve que la convergencia es lineal.

Se puede comprobar que:
$$
\left|x_{k + 1} - \frac{1}{6} \right| \le \frac{1}{2}\left|x_k - \frac{1}{6} \right|
$$
ya que 
$$
\left|x_{k + 1} - \frac{1}{6}\right| = \frac{1}{3 \cdot 2^{k + 1}} \qquad \left|x_k - \frac{1}{6} \right| = \frac{1}{3 \cdot 2^k}
$$
:::

::: caja-ejemplo
#### Ejemplo 3
Suponga que $C_p=0.5$ y que $\left| x_k - \overline x \right| < 0.01$. Considerando $p=1$ y $p=2$, analiza cómo se aproxima al valor límite, que se denotará por $\overline x$, considerando el término $k+1$ y $k+2$ de la sucesión $\{x_k\}$.

Se tiene que

* Si $p=1$,
$$
\begin{align*}
\left| x_{k + 1} - \overline x \right| &< C_p\left| x_{k} - \overline x \right| < 5 \cdot 10^{-1} \cdot 10^{-2} = 5 \cdot 10^{-3}\\
\left| x_{k + 2} - \overline x \right| &< C_p \left| x_{k + 1} - \overline x \right| <5 \cdot 10^{-1} \cdot (5 \cdot 10^{-3}) =25 \cdot 10^{-4}
\end{align*}
$$

* Si $p=2$,
$$
\begin{align*}
\left| x_{k + 1} - \overline x \right| & < C_p\left| x_{k} - \overline x \right|^2 < 5 \cdot 10^{-1} \cdot (10^{-2})^2 =5 \cdot 10^{-5}\\
\left| x_{k + 2} - \overline x \right| & < C_p \left| x_{k + 1} - \overline x \right|^2 < 5 \cdot 10^{-1} \cdot (5\cdot 10^{-5})^2=125 \cdot 10^{-11}
\end{align*}
$$
:::

# Método de Bisección

::: caja-lema
**Teorma del Valor Intermedio de Bolzano**

Supongamos que $f \in \mathcal{C}[a, b]$ y que $L$ es cualquier número entre $f(a)$ y $f(b)$. Entonces existe un número $c$ en $(a, b)$ tal que
$f(c) = L$.
:::

* Supongamos que $f$ es una función continua en un intervalo $[a, b]$, y $f(a) \cdot f(b) < 0$. Entonces, por el **Teorema de Bolzano**, existe al menos un $p \in (a, b)$, tal que $f(p) = 0$.

* El método, también llamado **método de intervalos encajados**, va construyendo una sucesión de intervalos encajados:
$$
[a_0,b_0] \supset[a_1,b_1]\supset\cdots\supset[a_n,b_n]\supset\cdots
$$
tal que el cero $x$ siempre está en todos los intervalos $[a_n,b_n]$ y la longitud de cada intervalo $[a_n,b_n]$ vale $\frac{b_0-a_0}{2^n}$. De esta manera el cero x se calcula de forma más precisa.

* Una primera aproximación de este punto $p$ puede ser el punto medio:

::: recuadro-gris
$$
p_1 = \dfrac{a_0+b_0}{2}
$$
:::

* Dado que la función es continua, si $f(a) \cdot f(p_1) < 0$ en el intervalo $[a, p_1]$ habrá al menos una solución de la ecuación.

* Y si $f(a) \cdot f(p_1) > 0$ en el intervalo $[p_1, b]$ existirá al menos una raíz.

* Por tanto se habrá definido un nuevo intervalo $[a_1, b_1]$ en el que existirá una solución. Al que puede aplicársele nuevamente el proceso anterior.

A continuación, se ilustra gráficamente el funcionamiento del método de bisección para la función $f(x) = x^2 - 4\sin(x)$ en el intervalo inicial $[1, 3]$.

```{python, echo=FALSE}
import numpy as np
import matplotlib.pyplot as plt

# 1. Definir la función y el intervalo inicial
def f(x):
    return x**2 - 4 * np.sin(x)

a, b = 1.0, 3.0
iteraciones = 4
historial = []

# 2. Ejecutar el método de bisección y guardar el historial
for i in range(iteraciones):
    m = (a + b) / 2
    fa, fb, fm = f(a), f(b), f(m)
    
    # Guardar los puntos de la iteración actual
    historial.append({'a': a, 'b': b, 'm': m, 'fa': fa, 'fb': fb, 'fm': fm})
    
    # Actualizar el intervalo
    if np.sign(fa) != np.sign(fm):
        b = m
    else:
        a = m

# 3. Preparar la gráfica
plt.figure(figsize=(12, 8))
x_vals = np.linspace(0, 3.5, 500)
y_vals = f(x_vals)

# Graficar la función y el eje x
plt.plot(x_vals, y_vals, label='$f(x) = x^2 - 4sin(x)$', color='black', zorder=1)
plt.axhline(0, color='gray', linestyle='--', linewidth=0.8)

# Denotar a_0 y b_0 en la gráfica
initial_a, initial_b = historial[0]['a'], historial[0]['b']
plt.text(initial_a, 0.5, '$a_0$', ha='center', va='bottom', fontsize=12, color='black')
plt.text(initial_b, 0.5, '$b_0$', ha='center', va='bottom', fontsize=12, color='black')

# 4. Graficar cada iteración del método
for i, data in enumerate(historial):
    color = plt.cm.get_cmap('tab10')(i)
    a_i, b_i, m_i = data['a'], data['b'], data['m']
    
    # Dibuja el intervalo [a, b] en el eje x
    plt.plot([a_i, b_i], [0, 0], '|', markersize=10, color=color, label=f'Intervalo {i+1}: [{a_i:.2f}, {b_i:.2f}]')
    plt.plot(m_i, 0, 'x', color=color, markersize=8, label=f'Punto medio {i+1}: {m_i:.2f}')
    
    # Añade la etiqueta p_i debajo de cada punto medio
    plt.text(m_i, -0.5, f'$p_{i+1}$', ha='center', va='top', color=color, fontsize=12)

# 5. Añadir detalles al gráfico
plt.title('Visualización del Método de Bisección')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True, linestyle=':', alpha=0.6)
plt.tight_layout()
plt.show()
```

::: cuadro-alg
**FUNCION BISECCION (f,a,b,TOL,N_MAX)**

    # f: la función para la cual se busca la raíz
    # a, b: los extremos del intervalo inicial [a, b]
    # TOL: la tolerancia para el criterio de parada
    # N_MAX: el número máximo de iteraciones

    # Paso 1: Verificar la condición inicial (f(a) y f(b) deben tener signos opuestos)
    SI f(a) * f(b) >= 0 ENTONCES
        IMPRIMIR "El método de bisección puede no funcionar. f(a) y f(b) deben tener signos opuestos."
        RETORNAR NULO
    FIN SI

    # Paso 2: Inicializar el contador de iteraciones
      iteracion = 0

    # Paso 3: Bucle principal de iteraciones
    MIENTRAS iteracion < N_MAX:
      # Calcular el punto medio del intervalo
      p = (a + b) / 2

      # Paso 4: Evaluar el criterio de parada (si f(p) es suficientemente cercano a cero)
      SI ABS(f(p)) < TOL ENTONCES
        IMPRIMIR "Raíz encontrada en p =", p, "en", iteracion, "iteraciones."
        RETORNAR p
      FIN SI

      # Paso 5: Actualizar el intervalo
      SI f(a) * f(p) < 0 ENTONCES
        # La raíz está en el subintervalo [a, p]
        b = p
      SINO
        # La raíz está en el subintervalo [p, b]
        a = p
      FIN SI

      # Paso 6: Incrementar el contador de iteraciones
      iteracion = iteracion + 1

      # Opcional: Criterio de parada basado en la longitud del intervalo
      SI (b - a) / 2 < TOL ENTONCES
        p = (a + b) / 2
        IMPRIMIR "Intervalo suficientemente pequeño. Raíz aproximada en p =", p, "en", iteracion, "iteraciones."
        RETORNAR p
      FIN SI
    FIN MIENTRAS

    # Paso 7: Si se alcanza el número máximo de iteraciones sin encontrar la raíz
    IMPRIMIR "Número máximo de iteraciones alcanzado. El método puede no haber convergido a la tolerancia deseada."
    RETORNAR (a + b) / 2 # Devolver la última aproximación
**FIN FUNCION**

:::

::: caja-ejemplo
#### Ejemplo 4: Bisección con seguimiento en tabla

A continuación, se aplica el método de bisección para encontrar una raíz de la función $f(x) = x^4 - 2x^3 - 4x^2 + 4x + 4$ en el intervalo $[-2, -1]$. La tabla muestra el progreso del método en cada iteración.

Verificando la hipótesis inicial del Método de Bisección
$$
f(-2) = (-2)^4-2(-2)^3-4(-2)^2+4(-2)+4 = 16+16-16-8+4 =12
$$
$$
f(-1) = (-1)^4-2(-1)^3-4(-1)^2+4(-1)+4 = 1+2-4-4+4 =-1
$$

Se observa que $f(-2)\cdot f(-1)<0$, por lo tanto el Teorema de Bolzano asegura la existencia de un valor $p\in(-2,-1)$ tal que $f(p)=0$

``` {python, echo=FALSE}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# 1. Definir la función
def f(x):
    return x**4 - 2*x**3 - 4*x**2 + 4*x + 4

# 2. Configuración inicial
a = -2.0
b = -1.0
TOL = 1e-5
nmax = 20

# Lista para almacenar los resultados de cada iteración
historial_tabla = []

# 3. Implementación del método de Bisección
k = 0
while k < nmax:
    p = a + (b - a) / 2
    fp = f(p)    
    error = (b - a) / 2
    error2 = 0
    if k > 0:
      error2 = np.abs(p-pold)
    pold = p
    
    
    # Almacenar los datos de la iteración actual
    historial_tabla.append([k + 1, a, b, p, np.abs(fp), error, error2])
    
    # Criterio de parada
    if error < TOL:
        print(f"Solución encontrada después de {k+1} iteraciones.")
        break
        
    # Actualizar el intervalo
    if f(a) * fp < 0:
        b = p
    else:
        a = p
        
    k += 1

# 4. Crear y mostrar la tabla con pandas
columnas = ['k', 'a', 'b', 'p_k', '|f(p_k)|', '(b-a)/2', '|p - pant|']
df = pd.DataFrame(historial_tabla, columns=columnas)
formatters = {
    'a': '{:.8f}'.format,
    'b': '{:.8f}'.format,
    'p_k': '{:.8f}'.format,
    '|f(p_k)|': '{:.4e}'.format,
    '(b-a)/2': '{:.4e}'.format,
    '|p - pant|': '{:.4e}'.format
}

print("Tabla de iteraciones del Método de Bisección:")
print(df.to_string(index=False, formatters=formatters))

# 5. Graficar la convergencia del error
plt.figure(figsize=(10, 6))
plt.plot(df['k'], df['(b-a)/2'], marker='o', linestyle='-', color='c', label='Error de intervalo |(b-a)/2|')
plt.plot(df['k'], df['|f(p_k)|'], marker='x', linestyle='--', color='m', label='Error de función |f(p_k)|')
plt.title('Convergencia del Error en el Método de Bisección')
plt.xlabel('Iteración (k)')
plt.ylabel('Valor del Error (escala logarítmica)')
plt.yscale('log')  # Usar escala logarítmica para ver mejor la convergencia
plt.legend()
plt.grid(True, which="both", ls="--")
plt.xticks(df['k']);
plt.show()
```
:::

* Observaciones:
  - Vemos que el método, es lento. Por ejemplo, para pasar de un error menor que 0.1 a un error menor que 0.01, usando el método de parada $|f(x_n)|<\epsilon$, se necesitan cuatro iteraciones apriximadamente, o sea, se necesitan cuatro iteraciones para “ganar” una cifra significativa en la aproximación del cero.
  - Los dos criterios de parada (dos últimas columnas) son equivalentes en el sentido que el nuevo aproximado $p_k$ se encuentra en el punto del intervalo $[a_{k-1},b_{k-1}]$.
  - Los dos criterios de parada (columna 4 y 6) son equivalentes desde el punto de vista de que se necesitan aproximadamente el mismo número de iteraciones para que se “gane” una cifra significativa en el cero. Además, los valores que se obtienen con los dos criterios son del mismo orden, es decir, que si en la iteración $n$, $|f(x_n)|\approx c_1⋅10^{-k}$, entonces $|x_n-x_{n-1}|\approx c_2⋅10^{-k}$; por ejemplo para $n=13$, $|f(x_{13})|\approx 2.31\cdot 10^{-4}$ y $|x_{13}-x_{12}|\approx 1.22\cdot 10^{-4}$.

# Método de Punto Fijo

* El método del punto fijo consiste en transformar la ecuación $f(x)=0$ en la ecuación $x=g(x)$ mediante operaciones algebraicas “básicas”.

* Entonces el cero de la ecuación $f(x)=0$ se transforma en lo que llamamos un punto fijo de la función $g(x)$:

::: caja-lema
**Definición de Punto Fijo**

Sea $g$ una función real de variable real. Diremos que $\hat{x}$ es un punto fijo de la función $g$ si $g(\hat{x})=\hat{x}$.
:::

**Observación**: Gráficamente, un punto fijo resulta de la intersección de la recta diagonal $y=x$ y de la función $y=g(x)$.

La idea es considerar la sucesión definida de forma recurrente como $x_n=g(x_{n-1})$ y ver bajo qué condiciones la sucesión $\{x_n\}_n$ converge hacia el punto fijo $\hat{x}$ de $g$ que recordemos será el cero de la función $f$ buscado.

::: cuadro-alg
**FUNCIÓN PUNTO_FIJO(g, p0, TOL, N_MAX)**

    # ENTRADA:
    #   g: la función de iteración x = g(x)
    #   p0: la aproximación inicial
    #   TOL: la tolerancia para el criterio de parada
    #   N_MAX: el número máximo de iteraciones

    # SALIDA:
    #   p: la solución aproximada o un mensaje de error

    i = 1
    MIENTRAS i <= N_MAX:
        # Calcular el siguiente término de la sucesión
        p = g(p0)

        # Verificar el criterio de parada (error absoluto)
        SI |p - p0| < TOL ENTONCES
            IMPRIMIR "Solución encontrada en p =", p, "en", i, "iteraciones."
            RETORNAR p
        FIN SI

        # Actualizar para la siguiente iteración
        i = i + 1
        p0 = p
    FIN MIENTRAS

    IMPRIMIR "El método fracasó después de", N_MAX, "iteraciones."

:::

```{python, echo=FALSE, fig.cap="Visualización de convergencia y divergencia en el Método de Punto Fijo.", fig.asp=0.6, out.width="100%"}
import numpy as np
import matplotlib.pyplot as plt
from typing import Callable, List, Tuple

def plot_cobweb(
    g: Callable[[float], float],
    p0: float,
    x_range: Tuple[float, float],
    max_iter: int = 10,
    ax: plt.Axes = None,
    **kwargs
):
    """
    Genera un diagrama de telaraña para visualizar el método de punto fijo.
    """
    if ax is None:
        fig, ax = plt.subplots(figsize=(10, 8))

    # Graficar g(x) y la línea y=x
    x_vals = np.linspace(*x_range, 400)
    ax.plot(x_vals, g(x_vals), label=f'$g(x)$', color=kwargs.get('g_color', 'purple'))
    ax.plot(x_vals, x_vals, label='$y = x$', color='red', linestyle='--')

    # Generar puntos para el diagrama de telaraña
    px, py = [p0], [0]
    p_current = p0
    for i in range(max_iter):
        p_next = g(p_current)
        px.extend([p_current, p_next])
        py.extend([p_next, p_next])
        p_current = p_next

    # Graficar las iteraciones
    ax.plot(px, py, color='orange', linestyle='-', marker='o', markersize=4, label='Iteraciones')
    ax.text(p0, -0.15, '$p_0$', ha='center', va='top', fontsize=12, color='darkorange')

    # Configuración del gráfico
    ax.axhline(0, color='black', linewidth=0.8)
    ax.axvline(0, color='black', linewidth=0.8)
    ax.set_title(kwargs.get('title', 'Diagrama de Telaraña'))
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.legend()
    ax.grid(True, linestyle=':', alpha=0.7)
    if 'ylim' in kwargs:
        ax.set_ylim(kwargs['ylim'])
    ax.set_aspect('equal', adjustable='box')

def g_converge(x: float) -> float:
    """Función g(x) = cos(x), que converge."""
    return np.cos(x)

def g_diverge(x: float) -> float:
    """Función g(x) = 1 - x^3, que diverge para p0=0.8."""
    return 1 - x**3

# --- Ejecución ---
# Crear una figura con dos subplots uno al lado del otro
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))

# Gráfico de convergencia
plot_cobweb(g=g_converge, p0=0.1, x_range=(0, 1.5), max_iter=10, ax=ax1, 
            title='Proceso Convergente', g_color='blue', ylim=(-0.2, 1.2))

# Gráfico de divergencia
plot_cobweb(g=g_diverge, p0=0.8, x_range=(-1, 1.5), max_iter=6, ax=ax2,
            title='Proceso Divergente', g_color='purple', ylim=(-1, 1.5))

plt.show()
```

::: caja-ejemplo
#### Ejemplo 5: Punto fijo para $f(x)=0$ de 4 maneras diferentes

Hallar numéricamente una de las raíces de $f(x) = x^2 - x - 2 = 0$. Sus raíces exactas son $x_1 = -1$ y $x_2 = 2$. Hallando únicamente en el cálculo de la raíz $\hat{x} = 2$ tomando como punto de partida $x_0 = 2.1$ y definiendo $g$ como.

* $g_1(x) = x^2-2$

* $g_2(x) = \sqrt{x+2}$

* $g_3(x) = 1+\dfrac{2}{x}$

* $g_4(x) = \dfrac{x^2+2}{2x-1}$

```{python, echo=FALSE}
import numpy as np
import pandas as pd
from itertools import zip_longest

# Definición de las funciones de iteración
def g1(x):
    return x**2 - 2

def g2(x):
    return np.sqrt(x + 2)

def g3(x):
    return 1 + 2/x

def g4(x):
    return (x**2 + 2) / (2*x - 1)

def fixed_point_iterations(g, p0, max_iter):
    """
    Realiza iteraciones de punto fijo y devuelve los resultados en una lista.
    """
    history = [p0]
    p_current = p0
    for i in range(max_iter):
        p_next = g(p_current)
        history.append(p_next)
        p_current = p_next
    return history

# Punto inicial
p0 = 2.1

# Calcular las iteraciones para cada función
iter_g1 = fixed_point_iterations(g1, p0, 10)
iter_g2 = fixed_point_iterations(g2, p0, 8)
iter_g3 = fixed_point_iterations(g3, p0, 15)
iter_g4 = fixed_point_iterations(g4, p0, 3)

# Combinar los resultados en una sola tabla
data = list(zip_longest(iter_g1, iter_g2, iter_g3, iter_g4))
df = pd.DataFrame(data, columns=['g1(x)', 'g2(x)', 'g3(x)', 'g4(x)'])
df.index.name = 'Iters'

# Mostrar la tabla combinada
print("--- Tabla Comparativa de Iteraciones de Punto Fijo ---")
print(df.to_string(
    formatters={
    'g1(x)': '{:.8e}'.format,
    'g2(x)': '{:.8f}'.format,
    'g3(x)': '{:.8f}'.format,
    'g4(x)': '{:.8f}'.format
},
    na_rep='---'
))

```

:::

------------------------------------------------------------------------
  
<small>Última revisión: `r format(Sys.Date(), "%d de %B, %Y")`</small>
