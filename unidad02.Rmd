---
title: "Álgebra Lineal Numérica"
author: "José Luis Ramírez"
date: "Octubre 2025"
output:
  html_document:
    self_contained: true
    mathjax: default
    pandoc_args: "--mathjax"
    toc: true
    toc_depth: 4
    toc_float: true
    theme: readable
    css: css/estilos.css
    number_sections: true
---

# Motivación

* En el planteamiento matemático de muchos problemas realistas, los sistemas de ecuaciones algebraicas, y de una manera especial los lineales, aparecen de manera natural.
* La búsqueda de métodos de resolución de sistemas de ecuaciones lineales es un tema de gran importancia en la ciencia.
* El objetivo de este tema es desarrollar estrategias numéricas que permitan resolver sistemas de ecuaciones relativamente grandes de una manera eficiente.
* El estudio de los autovalores de sistemas surge por doquier en muchas áreas de la ciencia, ingeniería, economía ...
  - Análisis de estructuras
  - Diseño de sistemas electrónicos
  - Análisis de sistemas eléctricos
  - Mercados financieros.
* Es también muy importante para analizar el comportamiento de métodos numéricos.

# Solución de Sistemas de Ecuaciones Lineales
* El objetivo de este tema es desarrollar estrategias numéricas que permitan resolver sistemas de ecuaciones relativamente grandes de una manera eficiente.
* Además, se analizarán con detalle algunos métodos directos.
* Si bien existen métodos exactos como el método de Cramer, estos son muy costosos de aplicar en situaciones donde los sistemas a resolver tienen muchas ecuaciones.
* El número total de operaciones para resolver un sistema de dimensión $n$ con este método es

::: recuadro-gris
$$
T_C = (n+1)^2n!-1
$$
$$
\begin{array}{|c|c|}\hline
n & T_C \\\hline
5 & 4319\\\hline
10 & 4\times10^{8}\\\hline
100 & 10\times10^{158}\\\hline
\end{array}
$$
:::

## Introducción
* Un sistema de $n$-ecuaciones (con coeficientes reales) en las $n$-incógnitas $x_1, x_2, \ldots , x_n$ es un conjunto de $n$ ecuaciones de la forma:

::: recuadro-gris
$$
\left\{
\begin{array}{rclclc}
a_{11}x_{1} & + & a_{12}x_{2} & + \cdots + & a_{1n}x_{n} & = b_{1} \\
a_{21}x_{1} & + & a_{22}x_{2} & + \cdots + & a_{2n}x_{n} & = b_{2} \\
\cdots & & \cdots & \cdots & \cdots & \cdots
\\ 
a_{n1}x_{1} & + & a_{n2}x_{2} & + \cdots + & a_{nn}x_{n} & = b_{n}
\end{array}
\right.
$$
:::
* A los números $a_{ij}$ se les denomina coeficientes del sistema y a los $b_i$ términos independientes.

Si se introducen las matrices

::: recuadro-gris
$$
A = \begin{pmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{n1} & a_{n2} & \cdots & a_{nn}
\end{pmatrix}, \quad
x = \begin{pmatrix}
x_{1} \\
x_{2} \\
\vdots \\
x_{n}
\end{pmatrix}, \quad
b = \begin{pmatrix}
b_{1} \\
b_{2} \\
\vdots \\
b_{n}
\end{pmatrix}
$$
:::

* El sistema de ecuaciones puede escribirse de forma matricial como

::: recuadro-gris
$$
Ax = b
$$
:::

### Clasificación
Podemos clasificar los sistemas de ecuaciones lineales atendiendo a:

* Su tamaño:
  - Pequeños: $n \leq 300$ donde $n$ representa el número de ecuaciones.
  - Grandes: $n > 300$
* Su estructura
  - Si la matriz posee pocos elementos nulos diremos que se trata de un sistema lleno.
  - Si, por el contrario, la matriz contiene muchos elementos nulos, diremos que la matriz, y por lo tanto, el sistema lineal es disperso o sparce.
  
### Solución
La primera opción que se plantea es

::: recuadro-gris
$$
x = A^{-1}b
$$
:::

* No es eficiente (demasiadas operaciones).
* Si el determinante de $A$ es próximo a cero, el error de redondeo puede ser muy grande, y esto es dificil de estimar numéricamente

::: recuadro-gris
$$
\det(\gamma A) = \gamma^n \det(A)
$$
:::

* Por lo tanto, se hace necesario desarrollar métodos numéricos que permitan resolver sistemas de ecuaciones lineales de una manera eficiente y con un control del error cometido.

## Métodos directos

### Sistemas triangulares
* Un sistema de ecuaciones lineales se dice que es triangular superior si su matriz de coeficientes $A$ es una matriz triangular superior, es decir, si todos los elementos situados por debajo de la diagonal principal son nulos.

::: recuadro-gris
$$
\left\{\begin{array}{r}
a_{11}x_1 + a_{12}x_2 + \cdots + a_{1i}x_i + \cdots + a_{1n}x_n = b_1 \\
a_{22}x_2 + \cdots + a_{2i}x_i + \cdots + a_{2n}x_n = b_2 \\
\vdots \\
a_{ii}x_i + \cdots + a_{in}x_n = b_i \\
\vdots \\
a_{nn}x_n = b_n\\
\end{array}\right.
$$
:::

* Como $a_{n,n} \ne 0$, se puede despejar $x_n$ de la última ecuación, y se obtiene:

::: recuadro-gris
$$
x_n = \dfrac{b_n}{a_{nn}}
$$
:::

* Sustituyendo este valor en la ecuación $n-1$ y despejando $x_{n-1}$ se tiene:

::: recuadro-gris
$$x_{n-1} = \dfrac{b_{n-1} - a_{n-1,n}x_n}{a_{n-1,n-1}}$$
:::

* Continuando este proceso, se obtiene la siguiente fórmula de recurrencia para $i = n-1, n-2, \ldots, 1$:

::: recuadro-gris
$$x_i = \dfrac{b_i - \displaystyle\sum_{j=i+1}^{n} a_{ij}x_j}{a_{ii}}$$
::: 

* Este proceso de resolución de sistemas triangulares superiores se denomina sustitución regresiva.

::: cuadro-alg
**FUNCION Sustitucion_Regresiva(A, b):**

    n = dimension de A (número de filas)

    # 1. Resolver la última incógnita (x_n)
    x[n] = b[n] / A[n, n]

    # 2. Iteración regresiva (desde n-1 hasta 1)
    PARA i = n-1 HASTA 1:
        suma = 0
        PARA j = i+1 HASTA n:
            suma = suma + A[i, j] * x[j]
        FIN PARA
        x[i] = (b[i] - suma) / A[i, i]
    FIN PARA

    RETORNAR x
**FIN FUNCION**
:::

```{python}
import numpy as np
def sustitucion_regresiva(A, b):
    n = len(b)
    x = np.zeros(n)
    x[n-1] = b[n-1] / A[n-1, n-1]
    for i in range(n-2, -1, -1):
        suma = np.dot(A[i, i+1:], x[i+1:])
        x[i] = (b[i] - suma) / A[i, i]
    return x
```

* En el caso de sistemas triangulares inferiores, el proceso es análogo, pero se realiza una sustitución progresiva.
* La fórmula de recurrencia para $i = 1, 2, \ldots, n-1, n$ es:
::: recuadro-gris
$$x_i = \dfrac{b_i - \displaystyle\sum_{j=1}^{i-1} a_{ij}x_j}{a_{ii}}$$
::: 
* El proceso de resolución de sistemas triangulares inferiores se denomina sustitución progresiva.

::: cuadro-alg
**FUNCION Sustitucion_Progresiva(A, b):**
    
    n = dimension de A (número de filas)

    # 1. Resolver la primera incógnita (x_1)
    x[1] = b[1] / A[1, 1]

    # 2. Iteración progresiva (desde 2 hasta n)
    PARA i = 2 HASTA n:
        suma = 0
        PARA j = 1 HASTA i-1:
            suma = suma + A[i, j] * x[j]
        FIN PARA
        x[i] = (b[i] - suma) / A[i, i]
    FIN PARA

    RETORNAR x
**FIN FUNCION**
:::

### Eliminación Gaussiana

* Suponiendo que $A$ no posee una estructura triangular, y es tal que no requiere intercambio de filas para transformar el sistema original en otro equivalente que sí la posea forma triangular.
* Una forma de resolver el sistema es transformar la matriz $A$ en una matriz triangular superior $U$ mediante operaciones elementales sobre las filas de la matriz.
* Digamos que el sistema original es:

::: recuadro-gris
$$
Ax = b \equiv \left\{
\begin{array}{l}
E_1: a_{11}x_{1}  +  a_{12}x_{2}  + \cdots +  a_{1n}x_{n}  = b_{1} \\
E_2: a_{21}x_{1}  +  a_{22}x_{2}  + \cdots +  a_{2n}x_{n}  = b_{2} \\
\cdots  \cdots  \cdots  \cdots  \cdots \cdots \cdots\\ 
E_n: a_{n1}x_{1}  +  a_{n2}x_{2}  + \cdots +  a_{nn}x_{n}  = b_{n}
\end{array}
\right.
$$  
:::

* Para eliminar la incógnita $x_1$ de las ecuaciones $E_2, E_3, \ldots, E_n$, se pueden realizar las siguientes operaciones elementales sobre las filas:

::: recuadro-gris
$$
E_i \leftarrow E_i - \dfrac{a_{i1}}{a_{11}} E_1 \quad \text{para } i = 2, 3, \ldots, n
$$
:::

* Los números $\dfrac{a_{i1}}{a_{11}}$ se denominan multiplicadores de eliminación.
* Después de aplicar estas operaciones, se obtiene un nuevo sistema equivalente:  
::: recuadro-gris
$$
A^{(1)}x = b^{(1)} \equiv \left\{
\begin{array}{l}
E_1: a_{11}x_{1}  +  a_{12}x_{2}  + \cdots +  a_{1n}x_{n}  = b_{1} \\
E_2: 0  +  a_{22}^{(1)}x_{2}  + \cdots +  a_{2n}^{(1)}x_{n}  = b_{2}^{(1)} \\
\cdots  \cdots  \cdots  \cdots  \cdots \cdots \cdots\\ 
E_n: 0  +  a_{n2}^{(1)}x_{2}  + \cdots +  a_{nn}^{(1)}x_{n}  = b_{n}^{(1)}
\end{array}
\right.
$$  
:::

* Repitiendo este proceso para las incógnitas $x_2, x_3, \ldots, x_{n-1}$, se obtiene finalmente un sistema triangular superior:

::: recuadro-gris
$$
Ux = y \equiv \left\{
\begin{array}{l}
E_1: u_{11}x_{1}  +  u_{12}x_{2}  + \cdots +  u_{1n}x_{n}  = y_{1} \\
E_2: 0  +  u_{22}x_{2}  + \cdots +  u_{2n}x_{n}  = y_{2} \\
\cdots  \cdots  \cdots  \cdots  \cdots \cdots \cdots\\ 
E_n: 0  +  0  + \cdots +  u_{nn}x_{n}  = y_{n}
\end{array}
\right.
$$  
:::

* Donde $U$ es una matriz triangular superior y $y$ es el nuevo vector de términos independientes.
* La solución del sistema original $Ax = b$ se obtiene resolviendo primero el sistema triangular superior $Ux = y$ mediante sustitución regresiva.

::: cuadro-alg
**FUNCION Eliminacion_Gauss(A, b):**
    
    n = dimension de A (número de filas)

    # 1. Eliminación hacia adelante
    PARA k = 1 HASTA n-1:
        PARA i = k+1 HASTA n:
            multiplicador = A[i, k] / A[k, k]
            A[i, k] = 0  # Elemento eliminado
            PARA j = k+1 HASTA n:
                A[i, j] = A[i, j] - multiplicador * A[k, j]
            FIN PARA
            b[i] = b[i] - multiplicador * b[k]
        FIN PARA
    FIN PARA
    RETORNAR A, b
**FIN FUNCION**
:::

::: caja-ejemplo
#### Ejemplo 1:
Resolver el sistema de ecuaciones lineales utilizando el método de eliminación de Gauss:
$$
\left\{
\begin{array}{rcl}
2x_1 + x_2 + x_3 & = & -3 \\
x_1 -2x_2 + 3x_3 & = & 6 \\
x_1  - x_2 - x_3 & = & 6
\end{array}
\right.
$$
```  {python}
import numpy as np
A = np.array([[2, 1, 1],
              [1, -2, 3],
              [1, -1, -1]], dtype=float)
b = np.array([-3, 6, 6], dtype=float)
def eliminacion_gauss(A, b):
    n = len(b)
    for k in range(n-1):
        for i in range(k+1, n):
            multiplicador = A[i, k] / A[k, k]
            A[i, k] = 0  # Elemento eliminado
            for j in range(k+1, n):
                A[i, j] = A[i, j] - multiplicador * A[k, j]
            b[i] = b[i] - multiplicador * b[k]
    return A, b
A_triangular, b_modificado = eliminacion_gauss(A, b)
print("Matriz triangular superior U:")
print(A_triangular)
print("Vector modificado y:")
print(b_modificado)
def sustitucion_regresiva(A, b):
    n = len(b)
    x = np.zeros(n)
    x[n-1] = b[n-1] / A[n-1, n-1]
    for i in range(n-2, -1, -1):
        suma = np.dot(A[i, i+1:], x[i+1:])
        x[i] = (b[i] - suma) / A[i, i]
    return x
solucion = sustitucion_regresiva(A_triangular, b_modificado)
print("Solución del sistema:")
print(solucion)
```
::: 

### Pivoteo
* En la eliminación gaussiana, es posible que durante el proceso de eliminación se encuentren elementos pivote que sean cero o muy pequeños, lo que puede llevar a errores numéricos significativos.

::: caja-ejemplo
#### Ejemplo 2:
Considere el siguiente sistema de ecuaciones lineales en una aritmética de punto flotante a 4 dígitos con redondeo correcto:
$$
\left\{
\begin{array}{rcl}
0.003000x_1 + 59.14x_2 & = & 59.17 \\
5.291x_1 - 6.130x_2 & = & 46.78
\end{array}
\right.
$$

cuya solución exacta es $x_1 = 10$ y $x_2 = 1$.

* Aplicando la eliminación gaussiana sin pivoteo, se obtiene el siguiente resultado $\tilde{x}_1=-10.00$ y $\tilde{x}_2=1.001$.
* El error relativo en la solución es:

::: recuadro-gris
$$
\begin{array}{l}
\text{Error relativo en } x_1 = \dfrac{|\tilde{x}_1 - x_1|}{|x_1|} = \dfrac{|-10.00 - 10|}{|10|} = 2.0 \\
\text{Error relativo en } x_2 = \dfrac{|\tilde{x}_2 - x_2|}{|x_2|} = \dfrac{|1.001 - 1|}{|1|} = 0.001
\end{array}
$$
:::
* El error tan grande de la solución numérica de $x_1$, resulta del error pequeño de $0.001$ al resolver para $x_2$.
:::

* Ahora, si se elige como pivote el máximo entre $a_{1,1}$ y $a_{2,1}$.
* Pivote =max(|0.003|; |5.291|) = 5.291, por tanto se realiza un intercambio de filas quedando el sistema de la siguiente manera:

::: recuadro-gris
$$
\left\{
\begin{array}{rcl}
5.291x_1 − 6.130x_2 &=& 46.78\\
0.003000x_1 + 59.14x_2 &=& 59.17
\end{array}\right.
$$
:::

* cuya solución aproximada es $\tilde{x}_2 = 1 = x_2$ y $\tilde{x}_1 = 10 = x_1$.
* Por tanto para cada paso de eliminación Gaussiana tenemos
que:
  - Seleccionar como pivote el elemento de mayor valor absoluto en la columna correspondiente, desde la fila actual hasta la última fila.
  - Intercambiar la fila actual con la fila que contiene el pivote seleccionado.
  
  ::: recuadro-gris
$$
\text{Pivoteo parcial: } \quad
E_i \leftrightarrow E_p \quad \text{donde } p = \underset{i \leq k \leq n}{\mathrm{argmax}} |a_{k,i}|
$$
:::

### Conteo de operaciones
* El número total de operaciones (sumas, restas, multiplicaciones y divisiones) necesarias para resolver un sistema de $n$ ecuaciones con $n$ incógnitas mediante el método de eliminación gaussiana es aproximadamente:

::: recuadro-gris
$(+/-)$
$$
\sum_{k=1}^{n-1} ((n-k)^2 + (n-k)) = \dfrac{1}{3}n^3 - \dfrac{1}{3}n \approx \mathcal{O}(n^3)
$$
$(×/÷)$
$$
\sum_{k=1}^{n-1} (2(n-k) + (n-k)^2) = \dfrac{2n^3+3n^2-5n}{6} \approx \mathcal{O}(n^3)
$$
::: 

### Número de condición
* ¿Cómo se evalua el buen o mal condicionamiento de la matriz de coeficientes?
* El número de condioción de una matriz permite cuantificar su nivel de condicionamiento.
* El número de condición de una matriz $A$ se define como:

::: recuadro-gris
$$\kappa(A) = ||A|| \cdot ||A^{-1}||
$$
:::

* Donde $||\cdot||$ denota una norma matricial.
* Si $\kappa(A)$ es cercano a 1, la matriz está bien condicionada.
* Si $\kappa(A)$ es grande, la matriz está mal condicionada.

::: caja-ejemplo
#### Ejemplo 3:
Calcular el número de condición de la siguiente matriz utilizando la norma 2:
$$A = \begin{pmatrix}
2 & 3.01 \\
4 & 6
\end{pmatrix}$$

```{python}
import numpy as np
A = np.array([[2, 3.01],
              [4, 6]], dtype=float)
def numero_de_condicion(A):
    norma_A = np.linalg.norm(A, 2)
    norma_A_inv = np.linalg.norm(np.linalg.inv(A), 2)
    kappa = norma_A * norma_A_inv
    return kappa
kappa_A = numero_de_condicion(A)
print("Número de condición de A:", kappa_A)
# Alternativamente, usando la función cond de NumPy
print(np.linalg.cond(A, 2))


```
:::

* Una cota válida para el nuúmero de condición es:

::: recuadro-gris
$$\kappa(A) \geq 1 $$
::: 

* Si $\kappa(A)$ es muy grande, pequeños errores en los datos de entrada pueden provocar grandes errores en la solución del sistema.

## Descomposición de Matrices

* Al aplicar el método de Gauss al sistema $Ax = b$ se realizan transformaciones elementales para triangularizar la matriz del sistema.
* Si este proceso puede realizarse sin intercambios de filas, la matriz triangular superior $U$ obtenida viene determinada por el producto de un número finito de transformaciones filas
$N_{n−1}N_{n−2}\cdots N_2N_1$ aplicadas a la matriz $A$. Llamando $L^{−1} = N_{n−1}N_{n−2}\cdots N_2N_1$ se tiene que

::: recuadro-gris
$$
L^{−1}A = U \Rightarrow A = LU.
$$
:::

* Además $L$ es una matriz triangular inferior con unos en la diagonal.
* Entonces para resolver el sistema $Ax = b$, sabiendo que $A$ posee descomposición $LU$, debemos hacer lo siguiente:
  - $Ax = b \Rightarrow LUx = b$, llamando $z$ al producto $Ux$ tenemos
que:
  - $Lz = b \Rightarrow$ sustitución progresiva.
  - $Ux = z \Rightarrow$ sustitución regresiva. 
  
Si $A$ es estrictamente diagonal dominante entonces $A$ admite una descomposición $LU$ que se obtiene mediante el proceso de eliminación Gaussiana.

::: recuadro-gris
Se dice que una matriz $A$ es diagonalmente dominante si
$$
|a_{ii}| > \sum_{\substack{j=1 \\ j \ne i}}^{n} |a_{ij}| \quad \text{para } i = 1, 2, \ldots, n
$$
:::

::: cuadro-alg
**FUNCION Descomposicion_LU(A):**
    
    n = dimension de A (número de filas)

    # 1. Inicializar L como la matriz identidad y U como una copia de A
    L = Matriz identidad de tamaño n
    U = Copia de A

    # 2. Proceso de eliminación para obtener U y L
    PARA k = 1 HASTA n-1:
        PARA i = k+1 HASTA n:
            multiplicador = U[i, k] / U[k, k]
            L[i, k] = multiplicador
            U[i, k] = 0  # Elemento eliminado
            PARA j = k+1 HASTA n:
                U[i, j] = U[i, j] - multiplicador * U[k, j]
            FIN PARA
        FIN PARA
    FIN PARA

    RETORNAR L, U
**FIN FUNCION**
:::

::: caja-ejemplo
#### Ejemplo 4:
Realizar la descomposición LU de la siguiente matriz:
$$A = \begin{pmatrix}
1 & 2 & 0 \\
-1 & 1 & 3 \\
2 & 1 & -1
\end{pmatrix}$$
```{python}
import numpy as np
A = np.array([[1, 2, 0],
              [-1, 1, 3],
              [2, 1, -1]], dtype=float)
def descomposicion_LU(A):
    n = A.shape[0]
    L = np.eye(n)
    U = A.copy()
    for k in range(n-1):
        for i in range(k+1, n):
            multiplicador = U[i, k] / U[k, k]
            L[i, k] = multiplicador
            U[i, k] = 0  # Elemento eliminado
            for j in range(k+1, n):
                U[i, j] = U[i, j] - multiplicador * U[k, j]
    return L, U
L, U = descomposicion_LU(A)
print("Matriz L:")
print(L)
print("Matriz U:")
print(U)
print("Verificación A = LU:")
print(np.dot(L, U))
```
:::

------------------------------------------------------------------------
  
<small>Última revisión: `r format(Sys.Date(), "%d de %B, %Y")`</small>
